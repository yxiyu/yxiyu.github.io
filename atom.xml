<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>熙羽`博客</title>
  
  <subtitle>生活明朗 万物可爱</subtitle>
  <link href="https://yxiyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://yxiyu.github.io/"/>
  <updated>2022-10-22T05:17:40.235Z</updated>
  <id>https://yxiyu.github.io/</id>
  
  <author>
    <name>熙羽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue基础</title>
    <link href="https://yxiyu.github.io/posts/c9970ee4"/>
    <id>https://yxiyu.github.io/posts/c9970ee4</id>
    <published>2022-09-27T00:12:18.000Z</published>
    <updated>2022-10-22T05:17:40.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue基础"><a href="#vue基础" class="headerlink" title="vue基础"></a>vue基础</h1><h2 id="vue-简介"><a href="#vue-简介" class="headerlink" title="vue 简介"></a>vue 简介</h2><div class="note blue no-icon flat"><p>概念：Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的前端框架。</p></div><h3 id="vue-的两个特性"><a href="#vue-的两个特性" class="headerlink" title="vue 的两个特性"></a>vue 的两个特性</h3><p>vue 框架的特性，主要体现在如下两方面：</p><ul><li>数据驱动视图</li><li>双向数据绑定</li></ul><ol><li>数据驱动视图<ul><li>数据的变化<strong>会驱动视图</strong>自动更新</li><li>好处：只管把数据维护好，那么页面结构会被 vue 自动渲染出来！</li></ul></li><li><p>双向数据绑定：</p><blockquote><p>在网页中，form 表单负责<strong>采集数据</strong>，Ajax 负责<strong>提交数据</strong>。  </p></blockquote><ul><li>js 数据的变化，会被自动渲染到页面上</li><li>页面上表单采集的数据发生变化的时候，会被 vue 自动获取到，并更新到 js 数据中</li></ul></li></ol><blockquote><p>注意：数据驱动视图是单向的数据绑定。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据驱动视图和双向数据绑定的底层原理是 <strong>MVVM</strong></p></blockquote><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><strong>MVVM</strong> 是 vue 实现<strong>数据驱动视图</strong>和<strong>双向数据绑定</strong>的核心原理。<br><strong>MVVM</strong> 指的是 <strong>Model、View 和 ViewModel，</strong>（Mode 数据源、View 视图、ViewModel 就是 vue 的实例）</p><h3 id="MVVM-的工作原理"><a href="#MVVM-的工作原理" class="headerlink" title="MVVM 的工作原理"></a>MVVM 的工作原理</h3><ul><li>ViewModel 作为 MVVM 的核心，是它把当前页面的数据源（Model）和页面的结构（View）连接在了一起。</li><li>当数据源发生变化时，会被 ViewModel 监听到，VM 会根据最新的数据源自动更新页面的结构</li><li>当表单元素的值发生变化时，也会被 VM 监听到，VM 会把变化过后最新的值自动同步到 Model 数据源中</li></ul><h2 id="vue-的基本使用"><a href="#vue-的基本使用" class="headerlink" title="vue 的基本使用"></a>vue 的基本使用</h2><ul><li>导入 vue.js 的 script 脚本文件</li><li>在页面中声明一个将要被 vue 所控制的 DOM 区域</li><li>创建 vm 实例对象（vue 实例对象）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/vue-2.6.12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;username&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 创建 vm 实例对象（vue 实例对象）</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//el属性是固定写法，表示当前 vm 实例 要控制页面上的哪个区域，结束的值是一个选择器</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//data 对象就是要渲染到页面上的数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">username</span>: <span class="string">&#x27;zs&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="vue-的指令与过滤器"><a href="#vue-的指令与过滤器" class="headerlink" title="vue 的指令与过滤器"></a>vue 的指令与过滤器</h2><h3 id="指令的概念"><a href="#指令的概念" class="headerlink" title="指令的概念"></a>指令的概念</h3><p>指令（Directives）是 vue 为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构<br>vue 中的指令按照不同的用途可以分为如下 6 大类：   </p><ul><li>内容渲染指令</li><li>属性绑定指令</li><li>事件绑定指令</li><li>双向绑定指令</li><li>条件渲染指令</li><li>列表渲染指令</li></ul><h3 id="内容渲染指令"><a href="#内容渲染指令" class="headerlink" title="内容渲染指令"></a>内容渲染指令</h3><p>内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。常用的内容渲染指令有如下 3 个</p><ol><li><p><code>v-text</code> 指令的缺点：会覆盖元素内部原有的内容！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;gender&quot;</span>&gt;</span>性别：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：v-text 指令会覆盖元素内默认的值。</p></blockquote></li><li><p><code>&#123;&#123; &#125;&#125;</code> 插值表达式：在实际开发中用的最多，只是内容的占位符，不会覆盖原有的内容！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &#123;&#123;&#125;&#125; 插值表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>性别：&#123;&#123;gender&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：相对于 v-text 指令来说，插值表达式在开发中更常用一些！因为它不会覆盖元素中默认的文本内容。</p></blockquote></li><li><code>v-html</code> 指令的作用：可以把带有标签的字符串，渲染成真正的 HTML 内容！<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;info&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="属性绑定指令"><a href="#属性绑定指令" class="headerlink" title="属性绑定指令"></a>属性绑定指令</h3><blockquote><p> 注意：插值表达式只能用在元素的<strong>内容节点</strong>中，不能用在元素的<strong>属性节点</strong>中！</p></blockquote><ul><li><p>在 vue 中，可以使用 <code>v-bind:</code> 指令，为元素的属性动态绑定值；</p></li><li><p>简写是英文的 <code>:</code></p></li><li><p>在使用 v-bind 属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，例如：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:placeholder</span>=<span class="string">&quot;tips&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;photo&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:title</span>=<span class="string">&quot;&#x27;box&#x27; + index&quot;</span>&gt;</span>这是一个 div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事件绑定指令"><a href="#事件绑定指令" class="headerlink" title="事件绑定指令"></a>事件绑定指令</h3><ol><li><p><code>v-on:</code> 简写是 <code>@</code></p></li><li><p>语法格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line"> // 如果在方法中要修改 data 中的数据，可以通过 this 访问到</span><br><span class="line">   add() &#123;</span><br><span class="line">this.count += 1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>$event</code> 的应用场景：如果默认的事件对象 e 被覆盖了，则可以手动传递一个  $event。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add(3, $event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line"> // 如果在方法中要修改 data 中的数据，可以通过 this 访问到</span><br><span class="line">   add(n, e) &#123;</span><br><span class="line">     this.count += 1      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>事件修饰符：</p><ul><li><p><code>.prevent</code>阻止跳转</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>.stop</code>阻止冒泡</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="v-model-指令"><a href="#v-model-指令" class="headerlink" title="v-model 指令"></a>v-model 指令</h3><ol><li>input 输入框<ul><li>type=”radio”</li><li>type=”checkbox”</li><li>type=”xxxx”</li></ul></li><li>textarea</li><li>select</li><li>v-model的修饰符 <code>.number</code>、<code>.trim</code>、<code>.lazy</code></li></ol><h3 id="条件渲染指令"><a href="#条件渲染指令" class="headerlink" title="条件渲染指令"></a>条件渲染指令</h3><ol><li><code>v-show</code> 的原理是：动态为元素添加或移除 <code>display: none</code> 样式，来实现元素的显示和隐藏<ul><li>如果要频繁的切换元素的显示状态，用 v-show 性能会更好</li></ul></li><li><code>v-if</code> 的原理是：每次动态创建或移除元素，实现元素的显示和隐藏<ul><li>如果刚进入页面的时候，某些元素默认不需要被展示，而且后期这个元素很可能也不需要被展示出来，此时 v-if 性能更好</li></ul></li></ol><blockquote><p> 在实际开发中，绝大多数情况，不用考虑性能问题，直接使用 v-if 就好了！！！</p></blockquote><p>v-if 指令在使用的时候，有两种方式：</p><ol><li><p>直接给定一个布尔值 true 或 false</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;true&quot;</span>&gt;</span>被 v-if 控制的元素<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>给 v-if 提供一个判断条件，根据判断的结果是 true 或 false，来控制元素的显示和隐藏</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>一般<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;D&#x27;&quot;</span>&gt;</span>差<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="列表渲染指令"><a href="#列表渲染指令" class="headerlink" title="列表渲染指令"></a>列表渲染指令</h3><p>v-for 列表渲染指令，是基于一个数组来循环渲染一个列表结构。v-for 指令需要使用 item in items 形式的特殊语法，其中：</p><ul><li>items 是待循环的数组</li><li>item 是被循环的每一项<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// html</span><br><span class="line"><span class="comment">&lt;!-- :key的值不能出错，否则会报错 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;item.name + index&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;  index &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;  item.id  &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123;  item.name  &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">---------------</span><br><span class="line">data:&#123;</span><br><span class="line">    list:[</span><br><span class="line">        &#123;id:1,name:&#x27;zs&#x27;&#125;,</span><br><span class="line">        &#123;id:2,name:&#x27;ls&#x27;&#125;,</span><br><span class="line">        &#123;id:3,name:&#x27;ww&#x27;&#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>key 的注意事项</p><ul><li>key 的值只能是字符串或数字类型</li><li>key 的值必须具有唯一性（即：key 的值不能重复）</li><li>建议把数据项 id 属性的值作为 key 的值（因为 id 属性的值具有唯一性）</li><li>使用 index 的值当作 key 的值没有任何意义（因为 index 的值不具有唯一性）</li><li>建议使用 v-for 指令时一定要指定 key 的值（既提升性能、又防止列表状态紊乱）</li></ul></blockquote><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p><code>过滤器（Filters）</code>常用于文本的格式化。过滤器可以用在两个地方：插值表达式和 v-bind 属性绑定<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>message 的值是：&#123;&#123; message | capitalize &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意点</p><ol><li>要定义到 filters 节点下，<strong>本质是一个函数</strong></li><li>在过滤器函数中，<strong>一定要有 return 值</strong></li><li>在过滤器的形参中，可以获取到“管道符”前面待处理的那个值</li><li>如果全局过滤器和私有过滤器名字一致，此时按照“<strong>就近原则</strong>”，调用的是”私有过滤器“</li></ol></blockquote><p><code>定义私有过滤器</code></p><blockquote><p>在创建 vue 实例期间，可以在 filters 节点中定义过滤器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;hello vue js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">filters</span>: &#123; <span class="comment">//在filters节点下定义过滤器</span></span><br><span class="line">    <span class="title function_">capitalize</span>(<span class="params">str</span>) &#123;</span><br><span class="line">    <span class="comment">// 把首字母转成大写</span></span><br><span class="line">      <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><p><code>定义全局过滤器</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vm实例对象 调用全局过滤器 需vm实例对象创建在定义全局过滤器之后 否则会报错，找不到过滤器</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&#x27;capitalize&#x27;</span>,<span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>());</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">charAt</span>(<span class="number">0</span>).<span class="title function_">toUpperCase</span>() + str.<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure><blockquote><p>过滤器可以串联地进行调用 <code>message | filterA | filterB ...</code><br>过滤器传参 <code>message | filterA(arg1,arg2)</code> <code>Vue.filter(&#39;filterA&#39;,(msg,arg1,arg2) =&gt; &#123;&#125;)</code></p></blockquote><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><h3 id="watch-侦听器"><a href="#watch-侦听器" class="headerlink" title="watch 侦听器"></a>watch 侦听器</h3><blockquote><p>watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做特定的操作。</p></blockquote><p><code>watch</code> 检测用户名是否可用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 监听 username 值的变化</span></span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">username</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal === <span class="string">&#x27;&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 使用 axios 发起请求，判断用户名是否可用</span></span><br><span class="line">        <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;https://www.escook.cn/api/finduser/&#x27;</span> + newVal)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意<br>默认情况下，组件在初次加载完毕后不会调用 watch 侦听器。如果想让 watch 侦听器立即被调用，则需要使用 <code>immediate</code> 选项。<br>如果 watch 侦听的是一个对象，如果对象中的属性值发生了变化，则无法被监听到。此时需要使用 <code>deep</code> 选项</p></blockquote><h3 id="侦听器的格式"><a href="#侦听器的格式" class="headerlink" title="侦听器的格式"></a>侦听器的格式</h3><ol><li>方法格式的侦听器<ul><li>缺点1：无法在刚进入页面的时候，自动触发！</li><li>缺点2：如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发侦听器！</li></ul></li><li>对象格式的侦听器<ul><li>好处1：可以通过 <strong>immediate</strong> 选项，让侦听器自动触发！</li><li>好处2：可以通过 <strong>deep</strong> 选项，让侦听器深度监听对象中每个属性的变化！</li></ul></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="comment">//方法格式的侦听器</span></span><br><span class="line">        username (newVal,oldVal) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//-----------------------------------------        </span></span><br><span class="line">        <span class="comment">// 对象格式的侦听器</span></span><br><span class="line">        <span class="attr">username</span>: &#123;</span><br><span class="line">            <span class="title function_">handler</span>(<span class="params">newVal,oldVal</span>)&#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal,oldVal);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 自动触发侦听器</span></span><br><span class="line">            <span class="attr">immediate</span>: <span class="literal">true</span>，</span><br><span class="line">            <span class="comment">// 开启深度监听</span></span><br><span class="line">            <span class="attr">deep</span>:<span class="literal">true</span>.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>特点：</p><ol><li>定义的时候，要被定义为“方法”</li><li>在使用计算属性的时候，当普通的属性使用即可</li></ol><p>好处：</p><ol><li>实现了代码的复用</li><li>只要计算属性中依赖的数据源变化了，则计算属性会自动重新求值！</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//html </span></span><br><span class="line"><span class="comment">// &lt;div class=&quot;box&quot; :style=&quot;&#123; backgroundColor: rgb &#125;&quot;&gt;</span></span><br><span class="line"><span class="comment">//   &#123;&#123; rgb &#125;&#125;</span></span><br><span class="line"><span class="comment">// &lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;button @click=&quot;show&quot;&gt;按钮&lt;/button&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">r</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">g</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 点击按钮，在终端显示最新的颜色</span></span><br><span class="line">    <span class="title function_">show</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">rgb</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//所有的计算属性 都要放到 computed 节点之下</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="title function_">rgb</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;<span class="variable language_">this</span>.r&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.g&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.b&#125;</span>)`</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><blockquote><p><code>vue-cli 是 Vue.js 开发的标准工具</code> 它简化了基于 webpack 创建工程化的 Vue 项目的过程。</p></blockquote><p><a href="https://cli.vuejs.org/zh/">中文官网</a></p><p><code>vue 项目的运行流程</code></p><blockquote><p>在工程化的项目中，vue 要做的事情很单纯：通过 main.js 把 App.vue 渲染到 index.html 的指定区域中。</p><ul><li>App.vue 用来编写待渲染的模板结构</li><li>index.html 中需要预留一个 el 区域</li><li>main.js 把 App.vue 渲染到了 index.html 所预留的区域中</li></ul></blockquote><h2 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h2><blockquote><p><code>组件化开发</code>指的是：根据<code>封装</code>的思想，<code>把页面上可重用的 UI 结构封装为组件</code>，从而方便项目的开发和维护。</p></blockquote><h3 id="vue-中的组件化开发"><a href="#vue-中的组件化开发" class="headerlink" title="vue 中的组件化开发"></a>vue 中的组件化开发</h3><ul><li>vue 是一个<code>支持组件化开发</code>的前端框架。</li><li>vue 中规定：<code>组件的后缀名</code>是 <code>.vue</code>。App.vue 文件本质上就是一个 vue 的组件。</li></ul><h3 id="vue-组件的三个组成部分"><a href="#vue-组件的三个组成部分" class="headerlink" title="vue 组件的三个组成部分"></a>vue 组件的三个组成部分</h3><ul><li>template -&gt; 组件的模板结构</li><li>script -&gt; 组件的 JavaScript 行为</li><li>style -&gt; 组件的样式</li></ul><blockquote><p>每个组件中必须包含 template 模板结构，而 script 行为和 style 样式是可选的组成部分。</p></blockquote><div class="tabs" id><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#-1"><span class="p red">template</span></button></li><li class="tab"><button type="button" data-href="#-2"><span class="p red">script</span></button></li><li class="tab"><button type="button" data-href="#-3"><span class="p red">style</span></button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="-1"><blockquote><p>每个组件对应的模板结构，需要定义到 <code>&lt;template&gt;</code> 节点中。<br>template 是 vue 提供的容器标签，只起到包裹性质的作用，它不会被渲染为真正的 DOM 元素<br>template 中只能包含唯一的根节点</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 当前组件的 DOM 结构，需要定义到 template 标签的内部 --&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-2"><blockquote><p>在 <code>&lt;script&gt; 节点中封装组件的 JavaScript 业务逻辑</code>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 默认导出。这是固定写法！</span><br><span class="line">export default &#123;</span><br><span class="line">  // data 数据源</span><br><span class="line">  // 注意：.vue 组件中的 data 不能像之前一样，不能指向对象。</span><br><span class="line">  // 注意：组件中的 data 必须是一个函数</span><br><span class="line">  data() &#123;</span><br><span class="line">    // 这个 return 出去的 &#123; &#125; 中，可以定义数据</span><br><span class="line">    return &#123;</span><br><span class="line">      username: &#x27;admin&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // 当前组件中的方法</span><br><span class="line">  methods: &#123; &#125;,</span><br><span class="line">  // 当前组件中的侦听器</span><br><span class="line">  watch: &#123;&#125;,</span><br><span class="line">  // 当前组件中的计算属性</span><br><span class="line">  computed: &#123;&#125;,</span><br><span class="line">  // 当前组件中的过滤器</span><br><span class="line">  filters: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="-3"><blockquote><p>每个组件对应的样式，需要定义到 <code>&lt;style&gt;</code> 节点中。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;less&quot;&gt;</span><br><span class="line">  // 在 &lt;style&gt; 标签上添加 lang=&quot;less&quot; 属性，即可使用 less 语法编写组件的样式</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="组件之间的父子关系"><a href="#组件之间的父子关系" class="headerlink" title="组件之间的父子关系"></a>组件之间的父子关系</h3><blockquote><p>组件在被封装好之后，彼此之间是相互独立的，不存在父子关系<br>在使用组件的时候，根据彼此的嵌套关系，形成了父子关系、兄弟关系</p></blockquote><h3 id="组件的基本调用与注册"><a href="#组件的基本调用与注册" class="headerlink" title="组件的基本调用与注册"></a>组件的基本调用与注册</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="number">3</span>：以标签形式使用刚才注册的组件 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">Count</span>&gt;</span><span class="tag">&lt;/<span class="name">Count</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;!-- <span class="number">1</span>：使用 <span class="keyword">import</span> 语法导入需要的组件 --&gt;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Count</span> <span class="keyword">from</span> <span class="string">&quot;./components/Count.vue&quot;</span>;</span><br><span class="line">&lt;!-- <span class="number">2</span>：使用 components 节点注册组件 --&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">Count</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>通过 components 注册的是私有子组件</p><p>在 main.js 入口文件中，通过 Vue.component() 方法 注册的是全局组件。</p></blockquote><h3 id="组件的-props"><a href="#组件的-props" class="headerlink" title="组件的 props"></a>组件的 props</h3><blockquote><p><code>props</code> 是组件的<code>自定义属性</code>，在封装通用组件的时候，合理地使用 props 可以极大的提高组件的复用性！</p><p>vue 规定：组件中封装的自定义属性是<code>只读的</code>，<code>不能直接修改</code> props 的值。否则会直接报错<br>要想修改 props 的值，可以把 props 的值转存到 data 中</p></blockquote><ul><li>default 来定义属性的默认值。</li><li>type 来定义属性的值类型。</li><li>required 选项，将属性设置为必填项。</li></ul><p>语法格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// props 是自定义属性，允许使用者通过自定义属性，为当前组件指定初始值</span></span><br><span class="line"><span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">init</span>: &#123;</span><br><span class="line">        <span class="comment">// 若调用时未传值 则 默认值(default) 为0</span></span><br><span class="line">        <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="comment">// type  规定传值类型</span></span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">        <span class="comment">// 必须传参 </span></span><br><span class="line">        <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组件之间的样式冲突问题"><a href="#组件之间的样式冲突问题" class="headerlink" title="组件之间的样式冲突问题"></a>组件之间的样式冲突问题</h3><blockquote><blockquote><p>默认情况下，写在 .vue 组件中的样式会全局生效，因此很容易造成多个组件之间的样式冲突问题。</p></blockquote></blockquote><p>导致组件之间样式冲突的根本原因是：</p><ul><li>单页面应用程序中，所有组件的 DOM 结构，都是基于唯一的 index.html 页面进行呈现的</li><li>每个组件中的样式，都会影响整个 index.html 页面中的 DOM 元素</li></ul><p>解决方法：</p><ul><li>为每个组件分配唯一的自定义属性,为 style 节点<code>scoped</code> 属性</li></ul><p><code>/deep/ 样式穿透</code></p><blockquote><blockquote><p>如果给当前组件的 style 节点添加了 scoped 属性，则当前组件的样式对其子组件是不生效的。如果想让某些样式对子组件生效，可以使用 /deep/ 深度选择器。</p></blockquote></blockquote><p><img src="/.io//../../img/pages/deep.png" alt="deep"></p><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><blockquote><p>axios 是一个专注于网络请求的库！</p></blockquote><ol><li><p>发起 GET 请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">  <span class="comment">// 请求方式</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">  <span class="comment">// 请求的地址</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>,</span><br><span class="line">  <span class="comment">// URL 中的查询参数</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------</span></span><br><span class="line"> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btnGET&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="comment">/* axios.get(&#x27;url地址&#x27;, &#123;</span></span><br><span class="line"><span class="comment">         // GET 参数</span></span><br><span class="line"><span class="comment">         params: &#123;&#125;</span></span><br><span class="line"><span class="comment">     &#125;) */</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;http://www.liulongbin.top:3006/api/getbooks&#x27;</span>, &#123;</span><br><span class="line">         <span class="attr">params</span>: &#123; <span class="attr">id</span>: <span class="number">1</span> &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">     &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>发起 POST 请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btnPost&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await！</span></span><br><span class="line">  <span class="comment">// await 只能用在被 async “修饰”的方法中</span></span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, </span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------</span></span><br><span class="line"> <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btnPOST&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="comment">// axios.post(&#x27;url&#x27;, &#123; /* POST 请求体数据 */ &#125;)</span></span><br><span class="line">   <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;http://www.liulongbin.top:3006/api/post&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">gender</span>: <span class="string">&#x27;女&#x27;</span> &#125;)</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="vscode插件"><a href="#vscode插件" class="headerlink" title="vscode插件"></a>vscode插件</h1><ol><li><p>自动闭合标签<br>Auto Close Tag </p></li><li><p>快速生成Vue基础页面<br>Vuter &amp;&amp; Vue 3 Snippets</p></li><li><p>规范代码</p></li></ol><p>ESlint</p><p><code>setting.json</code>配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ESLint 插件配置</span></span><br><span class="line"><span class="attr">&quot;editor.codeActionsOnSave&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;source.fixAll&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vue基础&quot;&gt;&lt;a href=&quot;#vue基础&quot; class=&quot;headerlink&quot; title=&quot;vue基础&quot;&gt;&lt;/a&gt;vue基础&lt;/h1&gt;&lt;h2 id=&quot;vue-简介&quot;&gt;&lt;a href=&quot;#vue-简介&quot; class=&quot;headerlink&quot; title=&quot;v</summary>
      
    
    
    
    <category term="Vue" scheme="https://yxiyu.github.io/categories/Vue/"/>
    
    
    <category term="vue" scheme="https://yxiyu.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="https://yxiyu.github.io/posts/71513ccb"/>
    <id>https://yxiyu.github.io/posts/71513ccb</id>
    <published>2022-07-25T00:00:00.000Z</published>
    <updated>2022-10-22T05:17:40.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h2><h3 id="Git-的特性"><a href="#Git-的特性" class="headerlink" title="Git 的特性"></a>Git 的特性</h3><ul><li>直接记录快照，而非差异比较</li><li>近乎所有的操作都是在本地执行的</li></ul><blockquote><p>在原有的文件版本的基础上生成一份新的文件，类似于备份；为了效率，若文件没有修改，Git不再重新储备该文件，而是保留一个链接指向之前储存的文件<br>缺点：暂用磁盘空间较大<br>优点：版本切换时非常快</p></blockquote><h3 id="Git中的三个区域"><a href="#Git中的三个区域" class="headerlink" title="Git中的三个区域"></a>Git中的三个区域</h3><ul><li>工作区</li><li>暂存区</li><li>Git仓库</li></ul><h3 id="Git中的三种状态"><a href="#Git中的三种状态" class="headerlink" title="Git中的三种状态"></a>Git中的三种状态</h3><ul><li>已修改（modified）</li><li>已暂存（staged）</li><li>已提交（committ）</li></ul><h3 id="Git的工作流程"><a href="#Git的工作流程" class="headerlink" title="Git的工作流程"></a>Git的工作流程</h3><ol><li>在工作区中修改文件</li><li>将你想要下次提交的更改进行暂存</li><li>提交更新，找到暂存区的文件，将快照永久性存储到Git仓库</li></ol><h2 id="账户配置"><a href="#账户配置" class="headerlink" title="账户配置"></a>账户配置</h2><ol><li>配置全局账户，对所有 Git 仓库有效<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&#x27;Your Name&#x27;</span></span><br><span class="line">git config --global user.email <span class="string">&#x27;Your Email&#x27;</span></span><br></pre></td></tr></table></figure></li><li>配置局部账户，只对当前 Git 仓库有效<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">&#x27;Your Name&#x27;</span></span><br><span class="line">git config --<span class="built_in">local</span> user.email <span class="string">&#x27;Your Email&#x27;</span></span><br></pre></td></tr></table></figure></li><li>查看全局配置<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure></li><li>查看局部配置<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> --list</span><br></pre></td></tr></table></figure></li></ol><h2 id="本地基本操作"><a href="#本地基本操作" class="headerlink" title="本地基本操作"></a>本地基本操作</h2><h3 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">git status -s</span><br></pre></td></tr></table></figure><h3 id="添加暂存区-git-add"><a href="#添加暂存区-git-add" class="headerlink" title="添加暂存区 git add"></a>添加暂存区 git <code>add</code></h3><ul><li>将当前目录及其子目录下所有变更添加到暂存区<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure></li><li>将本地库所有变更添加到暂存区<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure></li><li>指定文件添加暂存区<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add file1 file2 ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="提交本地库-git-commit"><a href="#提交本地库-git-commit" class="headerlink" title="提交本地库 git commit"></a>提交本地库 <code>git commit</code></h3><ul><li><p>提交所有变更   </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">git commit -m <span class="string">&#x27;日志信息&#x27;</span> -a</span><br></pre></td></tr></table></figure></li><li><p>提交当前目录及其子目录的变更</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;日志信息&#x27;</span> .</span><br></pre></td></tr></table></figure></li><li><p>提交指定文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;日志信息&#x27;</span> fileName</span><br></pre></td></tr></table></figure></li></ul><h2 id="比较差异-git-diff"><a href="#比较差异-git-diff" class="headerlink" title="比较差异 git diff"></a>比较差异 <code>git diff</code></h2><ol><li><p>比较工作区和暂存区的所有差异，只能查看旧文件的变更（包括修改和删除），不能查看新文件（因为新文件还为被 git 追踪）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure></li><li><p>比较指定文件工作区和暂存区的差异</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff fileName</span><br></pre></td></tr></table></figure></li><li><p>比较暂存区和 HEAD 的所有差异</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff fileName</span><br></pre></td></tr></table></figure></li><li><p>比较指定文件暂存区和 HEAD 的差异</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff fileName</span><br></pre></td></tr></table></figure></li><li><p>比较两个分支指定文件的差异</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 分支1 分支2 fileName</span><br></pre></td></tr></table></figure></li><li><p>比较两个版本的差异</p></li></ol><ul><li>以前者为基准看后者的变化</li><li>HEAD 表示最后一次 commit 对应的版本，HEAD~1 往前一个版本<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff 版本号1 版本号2</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git diff HEAD~1 HEAD</span><br><span class="line">git diff HEAD~2 HEAD</span><br></pre></td></tr></table></figure></li></ul><h2 id="查看日志信息-git-log"><a href="#查看日志信息-git-log" class="headerlink" title="查看日志信息 git log"></a>查看日志信息 <code>git log</code></h2><ol><li>查看简要日志信息<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></li><li>查看详细日志信息<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li><li>查看极简日志信息<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure></li><li>查看最近 n 次的版本信息<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n</span><br></pre></td></tr></table></figure></li><li>查看所有分支的版本历史<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all</span><br></pre></td></tr></table></figure></li><li>以图形形式展示版本历史<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure></li><li>查看涉及到指定文件的 commit 记录<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> fileName</span><br></pre></td></tr></table></figure></li><li>查看指定文件每一行修改对应的 commit 记录和作者<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame fileName</span><br></pre></td></tr></table></figure></li></ol><h2 id="分支命令"><a href="#分支命令" class="headerlink" title="分支命令"></a>分支命令</h2><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch 新分支            //基于当前分支创建分支 </span><br><span class="line"></span><br><span class="line">git branch 新分支 已有分支   //基于指定分支创建分支</span><br><span class="line"></span><br><span class="line">git branch 新分支 commitID   //基于某个 commit 创建分支</span><br><span class="line"></span><br><span class="line">git checkout -b 新分支       //基于当前分支创建分支并切换到新分支</span><br></pre></td></tr></table></figure><h3 id="查看本地分支"><a href="#查看本地分支" class="headerlink" title="查看本地分支"></a>查看本地分支</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch </span><br><span class="line"><span class="comment">#or</span></span><br><span class="line">git branch -v</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -d 分支名</span><br><span class="line"><span class="comment">#or强制删除本地分支</span></span><br><span class="line">git branch -D 分支</span><br></pre></td></tr></table></figure><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><ol><li>将 A 分支合并到当前分支，且为 merge 创建 commit<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge A</span><br></pre></td></tr></table></figure></li><li>将 A 分支合并到 B 分支，且为 merge 创建 commit<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge A B</span><br></pre></td></tr></table></figure></li><li>把当前分⽀基于 B 分⽀做 rebase，以便把 B 分⽀合⼊到当前分⽀<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase B</span><br></pre></td></tr></table></figure></li><li>把 A 分⽀基于 B 分⽀做 rebase，以便把 B 分⽀合⼊到 A 分⽀<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase B A</span><br></pre></td></tr></table></figure></li></ol><h2 id="版本穿梭与回滚"><a href="#版本穿梭与回滚" class="headerlink" title="版本穿梭与回滚"></a>版本穿梭与回滚</h2><ol><li>工作区指定文件恢复成和暂存区一样<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout file1 file2 ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># tips in the Git Bash</span></span><br><span class="line"><span class="comment"># use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory</span></span><br><span class="line">git restore file1 file2 ...</span><br></pre></td></tr></table></figure></li><li>暂存区指定文件恢复成和 HEAD 一样<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git reset file1 file2 ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># tips in the Git Bash</span></span><br><span class="line"><span class="comment"># use &quot;git restore --staged &lt;file&gt;...&quot; to unstage</span></span><br><span class="line">git restore --staged file1 file2 ...</span><br></pre></td></tr></table></figure></li><li>工作区和暂存区所有文件恢复成和 HEAD 一样<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure></li><li>工作区和暂存区所有文件恢复成和指定版本一样<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure></li></ol><h2 id="远程仓库交互"><a href="#远程仓库交互" class="headerlink" title="远程仓库交互"></a>远程仓库交互</h2><h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a><code>git remote</code></h3><ol><li>查看所有远程仓库地址别名<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li><li>为远程仓库起别名<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add 别名 地址</span><br></pre></td></tr></table></figure></li><li>删除远程仓库别名<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove 别名</span><br></pre></td></tr></table></figure></li><li>修改别名<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename 旧名 新名</span><br></pre></td></tr></table></figure></li></ol><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a><code>git clone</code></h3><ol><li>克隆远程仓库到本地<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 地址</span><br></pre></td></tr></table></figure></li><li>克隆远程仓库指定分支到本地<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b 远程仓库分支名 地址</span><br></pre></td></tr></table></figure></li></ol><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a><code>git pull</code></h3><p>拉取远程分支，并与本地分支合并<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull 别名 分支名</span><br></pre></td></tr></table></figure></p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a><code>git push</code></h3><ol><li>推送本地指定分支到仓库指定分支<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push 别名 本地分支:远程分支</span><br></pre></td></tr></table></figure></li><li>如果远程分支被省略，表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li><li>如果省略本地分支名，等同于推送一个空的本地分支到远程分支，表示删除指定的远程分支，等同于<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin :master</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line">git push origin --delete master</span><br></pre></td></tr></table></figure></li><li>强制推送<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h1&gt;&lt;h2 id=&quot;Git-基础&quot;&gt;&lt;a href=&quot;#Git-基础&quot; class=&quot;headerlink&quot; title=&quot;Git 基础&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Git" scheme="https://yxiyu.github.io/categories/Git/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack学习笔记</title>
    <link href="https://yxiyu.github.io/posts/71513ccb"/>
    <id>https://yxiyu.github.io/posts/71513ccb</id>
    <published>2022-07-25T00:00:00.000Z</published>
    <updated>2022-10-22T05:17:40.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="前端工程化和webpack"><a href="#前端工程化和webpack" class="headerlink" title="前端工程化和webpack"></a>前端工程化和webpack</h2><h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><div class="note blue no-icon flat"><p>前端工程化指的是：在企业级的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化、<br>标准化。</p></div><div class="note blue no-icon flat"><p>Vue 项目和 React 项目，都是基于工程化的方式进行开发的。</p></div><div class="note blue no-icon flat"><p>好处：前端开发自成体系，有一套标准的开发方案和流程。</p></div><p>前端工程化的解决方案    </p><ul><li><p>早期的前端工程化解决方案：</p><ul><li><a href="https://www.gruntjs.net/">grunt</a></li><li><a href="https://www.gulpjs.com.cn/">gulp</a></li></ul></li><li><p>目前主流的前端工程化解决方案：    </p><ul><li><a href="https://www.webpackjs.com/">webpack</a></li><li><a href="https://zh.parceljs.org/">parcel</a></li></ul></li></ul><h3 id="webpack-1"><a href="#webpack-1" class="headerlink" title="webpack"></a>webpack</h3><h4 id="webpack基础"><a href="#webpack基础" class="headerlink" title="webpack基础"></a>webpack基础</h4><div class="note blue no-icon flat"><p>概念：webpack 是前端项目工程化的具体解决方案。<br> 主要功能：它提供了友好的前端模块化开发支持，以及代码压缩混淆、处理浏览器端 JavaScript 的兼容性、性能优化等强大的功能。<br>好处：让程序员把工作的重心放到具体功能的实现上，提高了前端开发效率和项目的可维护性。<br> 注意：目前 Vue，React 等前端项目，基本上都是基于 webpack 进行工程化开发的.</p></div><h4 id="在项目中配置-webpack"><a href="#在项目中配置-webpack" class="headerlink" title="在项目中配置 webpack"></a>在项目中配置 webpack</h4><p>1.在项目根目录中，创建名为 webpack.config.js 的 webpack 配置文件，并初始化如下的基本配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span> <span class="comment">// mode 用来指定构建模式，可选值有 development 和 production </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.在 package.json 的 scripts 节点下，新增 dev 脚本如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;dev&quot;</span>: <span class="string">&quot;webpack&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>3.在终端中运行 npm run dev 命令，启动 webpack 进行项目的打包构建    </p><h4 id="mode-的可选值"><a href="#mode-的可选值" class="headerlink" title="mode 的可选值"></a>mode 的可选值</h4><span class="p red">mode 节点</span>的可选值有两个，分别是：   <br><div class="note blue no-icon flat"><p><span class="p red">development</span></p><ul><li>开发环境</li><li>不会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度快，适合在开发阶段使用</li></ul></div>    <div class="note blue no-icon flat"><p><span class="p red">production</span></p><ul><li>生产环境</li><li>会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度很慢，仅适合在项目发布阶段使用</li></ul></div><h4 id="webpack-中的默认约定"><a href="#webpack-中的默认约定" class="headerlink" title="webpack 中的默认约定"></a>webpack 中的默认约定</h4><p>在 webpack 4.x 和 5.x 的版本中，有如下的默认约定：    </p><ul><li>默认的打包入口文件为 src -&gt; index.js</li><li>默认的输出文件路径为 dist -&gt; main.js</li></ul><p>自定义打包的入口与出口<br>在 webpack.config.js 配置文件中，通过 entry 节点指定打包的入口。通过 output 节点指定打包的出口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;development&#x27;</span>, <span class="comment">// mode 用来指定构建模式，可选值有 development 和 production </span></span><br><span class="line">    <span class="attr">entry</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./src/index.js&#x27;</span>),<span class="comment">//打包的入口文件路径</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">join</span>(__dirname,<span class="string">&#x27;./dist&#x27;</span>),<span class="comment">//输出文件的存放路径</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span><span class="comment">//输出文件的名字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="webpack-中的插件"><a href="#webpack-中的插件" class="headerlink" title="webpack 中的插件"></a>webpack 中的插件</h4><div class="note blue no-icon flat"><p><span class="p red">webpack-dev-server</span><br>每当修改了源代码，webpack 会自动进行项目的打包和构建</p></div><div class="note blue no-icon flat"><p><span class="p red">html-webpack-plugin</span></p><ul><li>webpack 中的 HTML 插件（类似于一个模板引擎插件）</li></ul><ul><li>可以通过此插件自定制 index.html 页面的内容</li><li>通过 HTML 插件复制到项目根目录中的 index.html 页面，也被放到了内存中</li><li>HTML 插件在生成的 index.html 页面，自动注入了打包的 bundle.js 文件</li></ul></div><h4 id="webpack-中的-loader"><a href="#webpack-中的-loader" class="headerlink" title="webpack 中的 loader"></a>webpack 中的 loader</h4><ol><li>loader 概述    <div class="note blue no-icon flat"><p>webpack 默认只能打包处理以 .js 后缀名结尾的模块。其他非 .js 后缀名结尾的模块，webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错！</p></div></li><li>loader 的调用过程 <div class="img-wrap"><div class="img-bg"><img class="img" src="https://imgtg.com/image/g2bcG" alt="loader 的调用过程" style="width:400px;"></div><span class="image-caption">loader 的调用过程</span></div></li><li>打包处理 css 文件</li><li>打包处理 less 文件</li><li>打包处理样式表中与 url 路径相关的文件</li><li>打包处理 js 文件中的高级语法</li></ol><h4 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h4><h4 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h1&gt;&lt;h2 id=&quot;前端工程化和webpack&quot;&gt;&lt;a href=&quot;#前端工程化和webpack&quot; class</summary>
      
    
    
    
    <category term="Vue" scheme="https://yxiyu.github.io/categories/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Nodejs</title>
    <link href="https://yxiyu.github.io/posts/33b4e017"/>
    <id>https://yxiyu.github.io/posts/33b4e017</id>
    <published>2022-05-24T00:00:00.000Z</published>
    <updated>2022-10-22T05:17:40.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nodejs基础"><a href="#Nodejs基础" class="headerlink" title="Nodejs基础"></a>Nodejs基础</h1><p>  <a href="http://nodejs.cn/">官网传送门</a></p><h2 id="初识-Nodejs"><a href="#初识-Nodejs" class="headerlink" title="初识 Nodejs"></a>初识 Nodejs</h2><blockquote><p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine</p><p>Node.js® 是一个基于 Chrome V8 引擎 的 JavaScript 运行时环境</p></blockquote><ul><li>基于 Express 框架 (opens new window)，可以快速构建 Web 应用</li><li>基于 Electron 框架 (opens new window)，可以构建跨平台的桌面应用</li><li>基于 restify 框架 (opens new window)，可以快速构建 API 接口项目</li><li>读写和操作数据库、创建实用的命令行工具辅助前端开发、etc…</li></ul><h2 id="Buffer-缓冲区"><a href="#Buffer-缓冲区" class="headerlink" title="Buffer 缓冲区"></a>Buffer 缓冲区</h2><p>  <a href="http://nodejs.cn/api/buffer.html">Buffer 缓冲区文档</a>  </p><ul><li>Buffer 的结构与数组类似，操作方法也与数组类似</li><li>数组不能存储二进制文件，Buffer 是专门存储二进制数据的</li><li>Buffer 存储的是二进制数据，显示时以 16 进制的形式显示</li><li>Buffer 每一个元素范围是 00~ff，即 0~255、00000000~11111111</li><li>每一个元素占用一个字节内存</li><li>Buffer 是对底层内存的直接操作，因此大小一旦确定就不能修改  </li></ul><p>Buffer 常用方法：</p><ul><li>Buffer.from(str[, encoding])：将一个字符串转换为 Buffer</li><li>Buffer.alloc(size)：创建指定大小的 Buffer</li><li>Buffer.alloUnsafe(size)：创建指定大小的 Buffer，可能包含敏感数据（分配内存时不会清除内存残留的数据）</li><li>buf.toString()：将 Buffer 数据转为字符串</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello前端&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 占用内存的大小，一个汉字3字节 13</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf.<span class="property">length</span>)</span><br><span class="line"><span class="comment">// 字符串的长度 7</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>)</span><br><span class="line"><span class="comment">// 8进制输出第一个元素 145</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf[<span class="number">1</span>].<span class="title function_">toString</span>(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个10个字节的buffer</span></span><br><span class="line"><span class="keyword">var</span> buf2 = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">10</span>)</span><br><span class="line"><span class="comment">//通过索引，来操作buf中的元素</span></span><br><span class="line">buf2[<span class="number">0</span>] = <span class="number">88</span></span><br><span class="line">buf2[<span class="number">1</span>] = <span class="number">255</span></span><br><span class="line">buf2[<span class="number">2</span>] = <span class="number">0xaa</span></span><br><span class="line">buf2[<span class="number">3</span>] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> buf3 = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(buf3)</span><br></pre></td></tr></table></figure><h2 id="fs-文件系统模块"><a href="#fs-文件系统模块" class="headerlink" title="fs 文件系统模块"></a>fs 文件系统模块</h2><ul><li>fs 模块中所有的操作都有两种形式可供选择:同步和异步</li><li>同步文件系统会阻塞程序的执行，也就是除非操作完毕，否则不会向下执行代码</li><li>异步文件系统不会阻塞程序的执行，而是在操作完成时，通过回调函数将结果返回</li><li>实际开发很少用同步方式，因此只介绍异步方式</li></ul><p>打开模式：  </p><div class="table-container"><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>读取文件，文件不存在抛异常</td></tr><tr><td>r+</td><td>读写文件，文件不存在抛异常</td></tr><tr><td>rs</td><td>同步模式下打开文件用于读取</td></tr><tr><td>rs+</td><td>同步模式下打开文件用于读写</td></tr><tr><td>w</td><td>写文件，不存在则创建，存在则覆盖原有内容</td></tr><tr><td>wx</td><td>写文件，文件存在打开失败</td></tr><tr><td>w+</td><td>读写文件，不存在创建，存在截断</td></tr><tr><td>wx+</td><td>读写，存在打开失败</td></tr><tr><td>a</td><td>追加，不存在创建</td></tr><tr><td>ax</td><td>追加，存在失败</td></tr><tr><td>a+</td><td>追加和读取，不存在创建</td></tr><tr><td>ax+</td><td>追加和读取，存在失败</td></tr></tbody></table></div><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>简单文件读取<br>语法格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(path[, options], callback)</span><br></pre></td></tr></table></figure><ul><li>path：文件路径</li><li>options：配置选项，若是字符串则指定编码格式<ul><li>encoding：编码格式</li><li>flag：打开方式</li></ul></li><li>callback：回调函数<ul><li>err：错误信息</li><li>data：读取的数据，如果未指定编码格式则返回一个 Buffer</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./files/1.txt&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failed!&#x27;</span> + err.<span class="property">message</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;content:&#x27;</span> + data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制文件内容</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;C:/Users/笔记.mp3&quot;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(!err) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line"><span class="comment">// 将data写入到文件中</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&quot;C:/Users/hello.jpg&quot;</span>, data, <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!err)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;文件写入成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; );</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>流式文件读取  </p><ul><li>简单文件读取的方式会一次性读取文件内容到内存中，若文件较大，会占用过多内存影响系统性能，且读取速度慢</li><li>大文件适合用流式文件读取，它会分多次将文件读取到内存中  </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;C:/Users/笔记.mp3&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;a.mp3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听流的开启和关闭</span></span><br><span class="line"><span class="comment">// 这几个监听不是必须的</span></span><br><span class="line">rs.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;可读流打开了~~&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">once</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;可读流关闭了~~&#x27;</span>)</span><br><span class="line">  <span class="comment">//数据读取完毕，关闭可写流</span></span><br><span class="line">  ws.<span class="title function_">end</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;可写流打开了~~&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">once</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;可写流关闭了~~&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//要读取一个可读流中的数据，要为可读流绑定一个data事件，data事件绑定完毕自动开始读取数据</span></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">  <span class="comment">//将读取到的数据写入到可写流中</span></span><br><span class="line">  ws.<span class="title function_">write</span>(data)</span><br><span class="line">&#125;)</span><br><span class="line">简便方式：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;C:/Users/lilichao/Desktop/笔记.mp3&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;b.mp3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// pipe()可以将可读流中的内容，直接输出到可写流中</span></span><br><span class="line">rs.<span class="title function_">pipe</span>(ws)</span><br></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>简单文件写入  </p><p>语法格式：  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFile</span>(file, data[, options], callback)</span><br><span class="line">file：文件路径</span><br><span class="line">data：写入内容</span><br><span class="line">options：配置选项，包含 encoding, mode, flag；若是字符串则指定编码格式</span><br><span class="line">callback：回调函数</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./files/2.txt&#x27;</span>, <span class="string">&#x27;Hello Nodejs&#x27;</span>, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;failed!&#x27;</span> + err.<span class="property">message</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;C:/Users/hello.txt&#x27;</span>, <span class="string">&#x27;通过 writeFile 写入的内容&#x27;</span>, &#123; <span class="attr">flag</span>: <span class="string">&#x27;w&#x27;</span> &#125;, <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入成功！&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>流式文件写入  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步、异步、简单文件的写入都不适合大文件的写入，性能较差，容易导致内存溢出</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;hello3.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">once</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;流打开了~~&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">once</span>(<span class="string">&#x27;close&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;流关闭了~~&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ws向文件中输出内容</span></span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;通过可写流写入文件的内容&#x27;</span>)</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭流</span></span><br><span class="line">ws.<span class="title function_">end</span>()</span><br></pre></td></tr></table></figure><h3 id="路径动态拼接问题-dirname"><a href="#路径动态拼接问题-dirname" class="headerlink" title="路径动态拼接问题 __dirname"></a>路径动态拼接问题 __dirname</h3><ul><li>在使用 fs 模块操作文件时，如果提供的操作路径是以 ./ 或 ../ 开头的相对路径时，容易出现路径动态拼接错误的问题</li><li>原因：代码在运行的时候，会以执行 node 命令时所处的目录，动态拼接出被操作文件的完整路径</li><li>解决方案：在使用 fs 模块操作文件时，直接提供完整的路径，从而防止路径动态拼接的问题</li><li>__dirname 获取文件所处的绝对路径</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(__dirname + <span class="string">&#x27;/files/1.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span>(<span class="params">err, data</span>) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><p>验证路径是否存在：</p><ul><li>fs.exists(path, callback)</li><li>fs.existsSync(path)</li></ul><p>获取文件信息：</p><ul><li>fs.stat(path, callback)</li><li>fs.stat(path)</li></ul><p>删除文件：</p><ul><li>fs.unlink(path, callback)</li><li>fs.unlinkSync(path)</li></ul><p>列出文件：</p><ul><li>fs.readdir(path[,options], callback)</li><li>fs.readdirSync(path[, options])</li></ul><p>截断文件：</p><ul><li>fs.truncate(path, len, callback)</li><li>fs.truncateSync(path, len)</li></ul><p>建立目录：</p><ul><li>fs.mkdir(path[, mode], callback)</li><li>fs.mkdirSync(path[, mode])</li></ul><p>删除目录：</p><ul><li>fs.rmdir(path, callback)</li><li>fs.rmdirSync(path)</li></ul><p>重命名文件和目录：</p><ul><li>fs.rename(oldPath, newPath, callback)</li><li>fs.renameSync(oldPath, newPath)</li></ul><p>监视文件更改：  </p><ul><li>fs.watchFile(filename[, options], listener)</li></ul><h2 id="path-路径模块"><a href="#path-路径模块" class="headerlink" title="path 路径模块"></a>path 路径模块</h2><p>path 模块是 Node.js 官方提供的、用来处理路径的模块。它提供了一系列的方法和属性，用来满足用户对路径的处理需求。</p><h3 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h3><p>path.join()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 ../ 会抵消前面的路径</span></span><br><span class="line"><span class="comment">// ./ 会被忽略</span></span><br><span class="line"><span class="keyword">const</span> pathStr = path.<span class="title function_">join</span>(<span class="string">&#x27;/a&#x27;</span>, <span class="string">&#x27;/b/c&#x27;</span>, <span class="string">&#x27;../../&#x27;</span>, <span class="string">&#x27;./d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pathStr) <span class="comment">// \a\d\e</span></span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./files/1.txt&#x27;</span>), <span class="string">&#x27;utf8&#x27;</span>, <span class="keyword">function</span> (<span class="params">err, dataStr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(dataStr)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="获取路径中文件名"><a href="#获取路径中文件名" class="headerlink" title="获取路径中文件名"></a>获取路径中文件名</h3><p>path.basename()</p><p>使用 path.basename() 方法，可以获取路径中的最后一部分，常通过该方法获取路径中的文件名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.<span class="title function_">basename</span>(path[, ext])</span><br></pre></td></tr></table></figure><ul><li>path: 文件路径</li><li>ext: 文件扩展名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义文件的存放路径</span></span><br><span class="line"><span class="keyword">const</span> fpath = <span class="string">&#x27;/a/b/c/index.html&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullName = path.<span class="title function_">basename</span>(fpath)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName) <span class="comment">// index.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nameWithoutExt = path.<span class="title function_">basename</span>(fpath, <span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(nameWithoutExt) <span class="comment">// index</span></span><br></pre></td></tr></table></figure><h3 id="获取路径中文件扩展名"><a href="#获取路径中文件扩展名" class="headerlink" title="获取路径中文件扩展名"></a>获取路径中文件扩展名</h3><p>path.extname()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fpath = <span class="string">&#x27;/a/b/c/index.html&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fext = path.<span class="title function_">extname</span>(fpath)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fext) <span class="comment">// .html</span></span><br></pre></td></tr></table></figure><h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><p>http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。  </p><h3 id="创建基本-Web-服务器"><a href="#创建基本-Web-服务器" class="headerlink" title="创建基本 Web 服务器"></a>创建基本 Web 服务器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 web 服务器实例</span></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为服务器实例绑定 request 事件，监听客户端的请求</span></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> url = req.<span class="property">url</span></span><br><span class="line">  <span class="keyword">const</span> method = req.<span class="property">method</span></span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">`Your request url is <span class="subst">$&#123;url&#125;</span>, and request method is <span class="subst">$&#123;method&#125;</span>`</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(str)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 Content-Type 响应头，解决中文乱码的问题</span></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>)</span><br><span class="line">  <span class="comment">// 向客户端响应内容</span></span><br><span class="line">  res.<span class="title function_">end</span>(str)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server running at http://127.0.0.1:8080&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="实现简陋路由效果"><a href="#实现简陋路由效果" class="headerlink" title="实现简陋路由效果"></a>实现简陋路由效果</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>()</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">on</span>(<span class="string">&#x27;request&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> url = req.<span class="property">url</span></span><br><span class="line">  <span class="comment">// 设置默认的响应内容为 404 Not found</span></span><br><span class="line">  <span class="keyword">let</span> content = <span class="string">&#x27;&lt;h1&gt;404 Not found!&lt;/h1&gt;&#x27;</span></span><br><span class="line">  <span class="comment">// 判断用户请求的是否为 / 或 /index.html 首页</span></span><br><span class="line">  <span class="comment">// 判断用户请求的是否为 /about.html 关于页面</span></span><br><span class="line">  <span class="keyword">if</span> (url === <span class="string">&#x27;/&#x27;</span> || url === <span class="string">&#x27;/index.html&#x27;</span>) &#123;</span><br><span class="line">    content = <span class="string">&#x27;&lt;h1&gt;首页&lt;/h1&gt;&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url === <span class="string">&#x27;/about.html&#x27;</span>) &#123;</span><br><span class="line">    content = <span class="string">&#x27;&lt;h1&gt;关于页面&lt;/h1&gt;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">end</span>(content)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server running at http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><h3 id="模块化概念"><a href="#模块化概念" class="headerlink" title="模块化概念"></a>模块化概念</h3><ul><li>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。</li><li>模块化可提高代码的复用性和可维护性，实现按需加载。</li><li>模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。  </li></ul><h3 id="Node-js-中模块的分类"><a href="#Node-js-中模块的分类" class="headerlink" title="Node.js 中模块的分类"></a>Node.js 中模块的分类</h3><ul><li>内置模块</li><li>自定义模块</li><li>第三方模块</li></ul><h3 id="Node-js-中的模块作用域"><a href="#Node-js-中的模块作用域" class="headerlink" title="Node.js 中的模块作用域"></a>Node.js 中的模块作用域</h3><ul><li>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</li><li>防止全局变量污染</li></ul><h3 id="模块作用域的成员"><a href="#模块作用域的成员" class="headerlink" title="模块作用域的成员"></a>模块作用域的成员</h3><ul><li>自定义模块中都有一个 module 对象，存储了和当前模块有关的信息</li><li>在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 module.exports 指向的对象。</li><li>默认情况下，exports 和 module.exports 指向同一个对象。最终共享的结果，以 module.exports 指向的对象为准.</li></ul><h3 id="CommonJS-模块化规范"><a href="#CommonJS-模块化规范" class="headerlink" title="CommonJS 模块化规范"></a>CommonJS 模块化规范</h3><ul><li>每个模块内部，module 变量代表当前模块</li><li>module 变量是一个对象，module.exports 是对外的接口</li><li>加载某个模块即加载该模块的 module.exports 属性</li></ul><h3 id="模块加载机制"><a href="#模块加载机制" class="headerlink" title="模块加载机制"></a>模块加载机制</h3><p>模块第一次加载后会被缓存，即多次调用 require() 不会导致模块的代码被执行多次，提高模块加载效率。</p><h4 id="内置模块加载"><a href="#内置模块加载" class="headerlink" title="内置模块加载"></a>内置模块加载</h4><p>内置模块加载优先级最高。</p><h4 id="自定义模块加载"><a href="#自定义模块加载" class="headerlink" title="自定义模块加载"></a>自定义模块加载</h4><p>加载自定义模块时，路径要以 ./ 或 ../ 开头，否则会作为内置模块或第三方模块加载。  </p><p>导入自定义模块时，若省略文件扩展名，则 Node.js 会按顺序尝试加载文件： </p><ul><li>按确切的文件名加载</li><li>补全 .js 扩展名加载</li><li>补全 .json 扩展名加载</li><li>补全 .node 扩展名加载</li><li>报错</li></ul><h4 id="第三方模块加载"><a href="#第三方模块加载" class="headerlink" title="第三方模块加载"></a>第三方模块加载</h4><ul><li>若导入第三方模块， Node.js 会从当前模块的父目录开始，尝试从 /node_modules 文件夹中加载第三方模块。</li><li><p>如果没有找到对应的第三方模块，则移动到再上一层父目录中，进行加载，直到文件系统的根目录。<br>例如，假设在 C:\Users\bruce\project\foo.js 文件里调用了 require(‘tools’)，则 Node.js 会按以下顺序查找：</p></li><li><p>C:\Users\bruce\project\node_modules\tools</p></li><li>C:\Users\bruce\node_modules\tools</li><li>C:\Users\node_modules\tools</li><li>C:\node_modules\tools</li></ul><h4 id="目录作为模块加载"><a href="#目录作为模块加载" class="headerlink" title="目录作为模块加载"></a>目录作为模块加载</h4><p>当把目录作为模块标识符进行加载的时候，有三种加载方式：</p><ul><li>在被加载的目录下查找 package.json 的文件，并寻找 main 属性，作为 require() 加载的入口</li><li>如果没有 package.json 文件，或者 main 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 index.js 文件。</li><li>若失败则报错</li></ul><h1 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h1><h2 id="Express-简介"><a href="#Express-简介" class="headerlink" title="Express 简介"></a>Express 简介</h2><p>1.概念：Express 是基于 Node.js 平台，快速、开放、极简的 Web 开发框架。</p><p>2.通俗的理解：Express 的作用和 Node.js 内置的 http 模块类似，是专门用来创建 Web 服务器的。</p><p>3.Express 的本质：就是一个 npm 上的第三方包，提供了快速创建 Web 服务器的便捷方法。</p><p>4.Express 的中文官网： <a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn/</a></p><h3 id="进一步理解-Express"><a href="#进一步理解-Express" class="headerlink" title="进一步理解 Express"></a>进一步理解 Express</h3><p>思考：不使用 Express 能否创建 Web 服务器？</p><p>答案：能，使用 Node.js 提供的原生 http 模块即可。</p><p>思考：既生瑜何生亮（有了 http 内置模块，为什么还有用 Express）？</p><p>答案：http 内置模块用起来很复杂，开发效率低；Express 是基于内置的 http 模块进一步封装出来的，能够极大的提高开发效率。</p><p>思考：http 内置模块与 Express 是什么关系？</p><p>答案：类似于浏览器中 Web API 和 jQuery 的关系。后者是基于前者进一步封装出来的。</p><h3 id="Express-能做什么"><a href="#Express-能做什么" class="headerlink" title="Express 能做什么"></a>Express 能做什么</h3><p>最常见的两种服务器，分别是：</p><p> Web 网站服务器：专门对外提供 Web 网页资源的服务器。</p><p> API 接口服务器：专门对外提供 API 接口的服务器。</p><p>使用 Express，我们可以方便、快速的创建 Web 网站的服务器或 API 接口的服务器。</p><h2 id="Express-的基本使用"><a href="#Express-的基本使用" class="headerlink" title="Express 的基本使用"></a>Express 的基本使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i express@<span class="number">4.17</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h3 id="创建基本的-Web-服务器"><a href="#创建基本的-Web-服务器" class="headerlink" title="创建基本的 Web 服务器"></a>创建基本的 Web 服务器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建web 服务器</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动web服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">4000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;express server running at http://127.0.0.1:4000&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="监听客户端的请求"><a href="#监听客户端的请求" class="headerlink" title="监听客户端的请求"></a>监听客户端的请求</h3><p>监听客户端的 GET 和 POST 请求,并向客户端响应具体的内容<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 express 提供的res.send() 方法，向客户端响应一个 JSON 对象</span></span><br><span class="line">    res.<span class="title function_">send</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;zs&#x27;</span>,<span class="attr">age</span>:<span class="number">40</span>,<span class="attr">gender</span>:<span class="string">&#x27;男&#x27;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/user&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 express 提供的res.send() 方法，向客户端响应一个文本字符串</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;请求成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="获取-URL-中携带的查询参数"><a href="#获取-URL-中携带的查询参数" class="headerlink" title="获取 URL 中携带的查询参数"></a>获取 URL 中携带的查询参数</h3><p>通过 req.query 对象，可以访问到客户端通过查询字符串的形式，发送到服务器的数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 req.query 对象，可以获取 客户端发送过来的查询参数，</span></span><br><span class="line">    <span class="comment">// 默认情况下，req.query 是一个空对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(req.<span class="property">query</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="获取-URL-中的动态参数"><a href="#获取-URL-中的动态参数" class="headerlink" title="获取 URL 中的动态参数"></a>获取 URL 中的动态参数</h3><p>通过 req.params 对象，可以访问到 URL 中，通过：匹配到的动态参数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// :id 是一个动态的参数</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user/:id&#x27;</span>,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// req.params 是一个动态匹配到的 URL参数</span></span><br><span class="line">    <span class="comment">// 默认情况下，req.params 也是一个空对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">params</span>);</span><br><span class="line">    res.<span class="title function_">send</span>(req.<span class="property">params</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="托管静态资源"><a href="#托管静态资源" class="headerlink" title="托管静态资源"></a>托管静态资源</h2><h3 id="express-static"><a href="#express-static" class="headerlink" title="express.static()"></a>express.static()</h3><p>通过express.static()，可以非常方便地创建一个静态资源服务器，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 express.static 方法，快速的对外提供静态资源</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./preview&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">4000</span>,<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;express server running at 127.0.0.1:4000&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>注意：Express 在指定的静态目录中查找文件，并对外提供资源的访问路径。<br>因此，存放静态文件的目录名不会出现在 URL 中。</p><h3 id="托管多个静态资源目录"><a href="#托管多个静态资源目录" class="headerlink" title="托管多个静态资源目录"></a>托管多个静态资源目录</h3><p>果要托管多个静态资源目录，请多次调用 express.static() 函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./preview&#x27;</span>))</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">static</span>(<span class="string">&#x27;./clock&#x27;</span>))</span><br><span class="line"><span class="comment">//访问静态资源文件时，express.static() 函数会根据目录的添加顺序查找所需的文件。</span></span><br></pre></td></tr></table></figure></p><h3 id="挂载路径前缀"><a href="#挂载路径前缀" class="headerlink" title="挂载路径前缀"></a>挂载路径前缀</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/abc&#x27;</span>,express.<span class="title function_">static</span>(<span class="string">&#x27;./preview&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="Express路由"><a href="#Express路由" class="headerlink" title="Express路由"></a>Express路由</h2><h3 id="路由的概念"><a href="#路由的概念" class="headerlink" title="路由的概念"></a>路由的概念</h3><p>在 Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。<br>Express 中的路由分 3 部分组成，分别是请求的类型、请求的 URL 地址、处理函数，格式如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">METHOD</span>(<span class="variable constant_">PATH</span>,<span class="variable constant_">HANDLER</span>)</span><br></pre></td></tr></table></figure></p><h3 id="路由的匹配过程"><a href="#路由的匹配过程" class="headerlink" title="路由的匹配过程"></a>路由的匹配过程</h3><p>每当一个请求到达服务器之后，需要先经过路由的匹配，只有匹配成功之后，才会调用对应的处理函数。</p><p>在匹配时，会按照路由的顺序进行匹配，如果请求类型和请求的 URL 同时匹配成功，则 Express 会将这次请求，转交给对应的 function 函数进行处理。</p><p>路由匹配的注意点：</p><p>按照定义的先后顺序进行匹配</p><p>请求类型和请求的URL同时匹配成功，才会调用对应的处理函数</p><h3 id="模块化路由"><a href="#模块化路由" class="headerlink" title="模块化路由"></a>模块化路由</h3><p>为了方便对路由进行模块化的管理，Express 不建议将路由直接挂载到 app 上，而是推荐将路由抽离为单独的模块。</p><p>将路由抽离为单独模块的步骤如下：</p><p>1.创建路由模块对应的 .js 文件<br><br>2.调用 express.Router() 函数创建路由对象<br><br>3.向路由对象上挂载具体的路由<br><br>4.使用 module.exports 向外共享路由对象<br><br>5.使用 app.use() 函数注册路由模块<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块化路由</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.use(&#x27;/files&#x27;, express.static(&#x27;./files&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./03.router&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. 注册路由模块</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, router)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意： app.use() 函数的作用，就是来注册全局中间件</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="comment">// 这是路由模块</span></span><br><span class="line"><span class="comment">// 1. 导入 express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 2. 创建路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 挂载具体的路由</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/user/list&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;Get user list.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/user/add&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;Add new user.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 向外导出路由对象</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Express-中间件"><a href="#Express-中间件" class="headerlink" title="Express 中间件"></a>Express 中间件</h2><h3 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h3><p>中间件（Middleware ），特指业务流程的中间处理环节。<br><br>服务器收到请求后，可先调用中间件进行预处理<br><br>中间件是一个函数，包含 req, res, next 三个参数，next() 参数把流转关系交给下一个中间件或路由<br><br>中间件注意事项；<br><br>1、在注册路由之前注册中间件（错误级别中间件除外）<br><br>2、中间件可连续调用多个<br><br>3、别忘记调用 next() 函数<br><br>4、next() 函数后别写代码<br><br>5、多个中间件共享 req、 res对象<br></p><h3 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h3><p>通过 app.use() 定义的中间件为全局中间件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 定义一个最简单的中间件函数</span></span><br><span class="line"><span class="comment">// const mw = function (req, res, next) &#123;</span></span><br><span class="line"><span class="comment">//   console.log(&#x27;这是最简单的中间件函数&#x27;)</span></span><br><span class="line"><span class="comment">//   // 把流转关系，转交给下一个中间件或路由</span></span><br><span class="line"><span class="comment">//   next()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 将 mw 注册为全局生效的中间件</span></span><br><span class="line"><span class="comment">// app.use(mw)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是定义全局中间件的简化形式</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是最简单的中间件函数&#x27;</span>)</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;调用了 / 这个路由&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;Home page.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;调用了 /user 这个路由&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;User page.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">80</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://127.0.0.1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Express 中间件的调用流程<br><br>当一个请求到达 Express 的服务器之后，可以连续调用多个中间件，从而对这次请求进行预处理。</p><h3 id="局部生效的中间件"><a href="#局部生效的中间件" class="headerlink" title="局部生效的中间件"></a>局部生效的中间件</h3><p>不使用 app.use() 定义的中间件，叫做局部生效的中间件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义中间件函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mw1</span> = (<span class="params">req,res,next</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;调用了第一个局部生效的中间件&#x27;</span>);</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mw2</span>= (<span class="params">req,res,next</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;调用了第二个局部生效的中间件&#x27;</span>);</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>,mw1,mw2,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;Home&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user&#x27;</span>,mw2,<span class="function">(<span class="params">req,res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">4000</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;http://127.0.0.1:4000&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ol>中间件的5个使用注意事项<li>一定要在路由之前注册中间件</li><li>客户端发送过来的请求，可以连续调用多个中间件进行处理</li><li>执行完中间件的业务代码之后，不要忘记调用 next() 函数</li><li>为了防止代码逻辑混乱，调用 next() 函数后不要再写额外的代码</li><li>连续调用多个中间件时，多个中间件之间，共享 req 和 res 对象</li></ol><h3 id="中间件的分类"><a href="#中间件的分类" class="headerlink" title="中间件的分类"></a>中间件的分类</h3><p>为了方便大家理解和记忆中间件的使用，Express 官方把常见的中间件用法，分成了 5 大类，分别是：<br></p><p> 1.应用级别的中间件<br></p><p> 通过 app.use() 或 app.get() 或 app.post() ，绑定到 app 实例上的中间件<br></p><p> 2.路由级别的中间件<br></p><p> 绑定到 express.Router() 实例上的中间件，叫做路由级别的中间件。用法和应用级别中间件没有区别。应用级别中间件是绑定到 app 实例上，路由级别中间件绑定到 router 实例上。<br></p><p> 3.错误级别的中间件<br></p><p>用来捕获整个项目中发生的异常错误，从而防止项目异常崩溃的问题<br><br>错误级别中间件的处理函数中，必须有 4 个形参，形参顺序从前到后分别是 (err, req, res, next) 。<br><br>错误级别的中间件必须注册在所有路由之后<br><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 express 模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建 express 的服务器实例</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 定义路由</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1.1 人为的制造错误</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;服务器内部发生了错误！&#x27;</span>)</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;Home page.&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义错误级别的中间件，捕获整个项目的异常错误，从而防止程序的崩溃</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生了错误！&#x27;</span> + err.<span class="property">message</span>)</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;Error：&#x27;</span> + err.<span class="property">message</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">const app = express()</span></span><br><span class="line"><span class="string">const router = express.Router()</span></span><br><span class="line"><span class="string">router.use(function (req, res, next) &#123;</span></span><br><span class="line"><span class="string">  console.log(1)</span></span><br><span class="line"><span class="string">  next()</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">app.use(&#x27;/&#x27;, router)</span></span><br><span class="line"><span class="string">// 调用 app.listen 方法，指定端口号并启动web服务器</span></span><br><span class="line"><span class="string">app.listen(80, function () &#123;</span></span><br><span class="line"><span class="string">  console.log(&#x27;Express server running at http://127.0.0.1&#x27;)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure></p><p> 4.Express 内置的中间件<br><br><br></p><ul>自 Express 4.16.0 版本开始，Express 内置了 3 个常用的中间件，极大的提高了 Express 项目的开发效率和体验：<li>express.static 快速托管静态资源的内置中间件，例如： HTML 文件、图片、CSS 样式等（无兼容性）</li><li>express.json 解析 JSON 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li><li>express.urlencoded 解析 URL-encoded 格式的请求体数据（有兼容性，仅在 4.16.0+ 版本中可用）</li></ul> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br></pre></td></tr></table></figure><p> 5.第三方的中间件<br></p><h2 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS 跨域资源共享"></a>CORS 跨域资源共享</h2><h3 id="cors-中间件解决跨域"><a href="#cors-中间件解决跨域" class="headerlink" title="cors 中间件解决跨域"></a>cors 中间件解决跨域</h3><ul><li>安装中间件：npm install cors</li><li>导入中间件：const cors = require('cors')</li><li>配置中间件：app.use(cors())</li></ul><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><ul><li>CORS（Cross-Origin Resource Sharing，跨域资源共享）解决跨域，是通过 HTTP 响应头决定浏览器是否阻止前端 JS 代码跨域获取资源</li><li>浏览器的同源安全策略默认会阻止网页“跨域”获取资源。但如果接口服务器配置了 CORS 相关的 HTTP 响应头，就可解除浏览器端的跨域访问限制</li><li>CORS 主要在服务器端进行配置。客户端浏览器无须做任何额外的配置，即可请求开启了 CORS 的接口。</li><li>CORS 在浏览器中有兼容性。只有支持 XMLHttpRequest Level2 的浏览器，才能正常访问开启了 CORS 的服务端接口（例如：IE10+、Chrome4+、FireFox3.5+）。</li></ul><h3 id="CORS-常见响应头"><a href="#CORS-常见响应头" class="headerlink" title="CORS 常见响应头"></a>CORS 常见响应头</h3><li>Access-Control-Allow-Origin：制定了允许访问资源的外域 URL</li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://bruceblog.io&#x27;</span>)</span><br><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure><li>Access-Control-Allow-Headers</li><li>默认情况下，CORS 仅支持客户端向服务器发送如下的 9 个请求头：Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type （值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一）</li><li>如果客户端向服务器发送了额外的请求头信息，则需要在服务器端，通过 Access-Control-Allow-Headers 对额外的请求头进行声明，否则这次请求会失败！</li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="string">&#x27;Content-Type, X-Custom-Header&#x27;</span>)</span><br></pre></td></tr></table></figure><li>Access-Control-Allow-Methods</li><li>默认情况下，CORS 仅支持客户端发起 GET、POST、HEAD 请求。如果客户端希望通过 PUT、DELETE 等方式请求服务器的资源，则需要在服务器端，通过 Access-Control-Alow-Methods 来指明实际请求所允许使用的 HTTP 方法</li><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res.<span class="title function_">setHeader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;POST, GET, DELETE, HEAD&#x27;</span>)</span><br><span class="line">res.<span class="title function_">setHEader</span>(<span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="CORS-请求分类"><a href="#CORS-请求分类" class="headerlink" title="CORS 请求分类"></a>CORS 请求分类</h3><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><li>请求方式：GET、POST、HEAD 三者之一</li><li>HTTP 头部信息不超过以下几种字段：无自定义头部字段、Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Viewport-Width、Width 、Content-Type（只有三个值 application/x-www-formurlencoded、multipart/form-data、text/plain）</li><h3 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h3><li>请求方式为 GET、POST、HEAD 之外的请求 Method 类型</li><li>请求头中包含自定义头部字段</li><li>向服务器发送了 application/json 格式的数据</li><p>在浏览器与服务器正式通信之前，浏览器会先发送 OPTION 请求进行预检，以获知服务器是否允许该实际请求，所以这一次的 OPTION 请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据</p><h2 id="使用-Express-写接口"><a href="#使用-Express-写接口" class="headerlink" title="使用 Express 写接口"></a>使用 Express 写接口</h2><h3 id="创建-API-路由模块"><a href="#创建-API-路由模块" class="headerlink" title="创建 API 路由模块"></a>创建 API 路由模块</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//API 路由模块</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">//bind your route here</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入路由模块</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./apiRouter&#x27;</span>)</span><br><span class="line"><span class="comment">// 把路由模块，注册到 app 上</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/api&#x27;</span>, router)</span><br></pre></td></tr></table></figure><h3 id="编写-GET-接口"><a href="#编写-GET-接口" class="headerlink" title="编写 GET 接口"></a>编写 GET 接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/get&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 req.query 获取客户端通过查询字符串，发送到服务器的数据</span></span><br><span class="line">  <span class="keyword">const</span> query = req.<span class="property">query</span></span><br><span class="line">  <span class="comment">// 调用 res.send() 方法，向客户端响应处理的结果</span></span><br><span class="line">  res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">0</span>, <span class="comment">// 0 表示处理成功，1 表示处理失败</span></span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;GET 请求成功！&#x27;</span>, <span class="comment">// 状态的描述</span></span><br><span class="line">    <span class="attr">data</span>: query, <span class="comment">// 需要响应给客户端的数据</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="编写-POST-接口"><a href="#编写-POST-接口" class="headerlink" title="编写 POST 接口"></a>编写 POST 接口</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 POST 接口</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/post&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 req.body 获取请求体中包含的 url-encoded 格式的数据</span></span><br><span class="line">  <span class="keyword">const</span> body = req.<span class="property">body</span></span><br><span class="line">  <span class="comment">// 调用 res.send() 方法，向客户端响应结果</span></span><br><span class="line">  res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">msg</span>: <span class="string">&#x27;POST 请求成功！&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: body,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JSONP-接口"><a href="#JSONP-接口" class="headerlink" title="JSONP 接口"></a>JSONP 接口</h3><p>！！如果项目中已经配置了 CORS 跨域资源共享，为了防止冲突，必须在配置 CORS 中间件之前声明 JSONP 的接口。否则 JSONP 接口会被处理成开启了 CORS 的接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须在配置 cors 中间件之前，配置 JSONP 的接口</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/jsonp&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 定义 JSONP 接口具体的实现过程</span></span><br><span class="line">  <span class="comment">// 1. 得到函数的名称</span></span><br><span class="line">  <span class="keyword">const</span> funcName = req.<span class="property">query</span>.<span class="property">callback</span></span><br><span class="line">  <span class="comment">// 2. 定义要发送到客户端的数据对象</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line">  <span class="comment">// 3. 拼接出一个函数的调用</span></span><br><span class="line">  <span class="keyword">const</span> scriptStr = <span class="string">`<span class="subst">$&#123;funcName&#125;</span>(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span></span><br><span class="line">  <span class="comment">// 4. 把拼接的字符串，响应给客户端</span></span><br><span class="line">  res.<span class="title function_">send</span>(scriptStr)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;##btnJsonp&#x27;</span>).<span class="title function_">on</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    $.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>:<span class="string">&#x27;http://127.0.0.1/api/jsonp&#x27;</span>,</span><br><span class="line">        <span class="attr">dataType</span>:<span class="string">&#x27;jsonp&#x27;</span>,<span class="comment">//表示要发起jsonp请求</span></span><br><span class="line">        <span class="attr">success</span>:<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数据库和身份认证"><a href="#数据库和身份认证" class="headerlink" title="数据库和身份认证"></a>数据库和身份认证</h1><h2 id="Node-操作-mysql"><a href="#Node-操作-mysql" class="headerlink" title="Node 操作 mysql"></a>Node 操作 mysql</h2><h3 id="配置-mysql-模块"><a href="#配置-mysql-模块" class="headerlink" title="配置 mysql 模块"></a>配置 mysql 模块</h3><p>1.安装 mysql 模块<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql</span><br></pre></td></tr></table></figure><br>2.建立连接<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> db = mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">  <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">  <span class="attr">database</span>: <span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>3.测试是否正常工作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;select 1&#x27;</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="操作-mysql-数据库"><a href="#操作-mysql-数据库" class="headerlink" title="操作 mysql 数据库"></a>操作 mysql 数据库</h3><p>1.查询数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;select * from users&#x27;</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>2.插入数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ? 表示占位符</span></span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">&#x27;insert into users values(?, ?)&#x27;</span></span><br><span class="line"><span class="comment">// 使用数组的形式为占位符指定具体的值</span></span><br><span class="line">db.<span class="title function_">query</span>(sql, [username, password], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err.<span class="property">message</span>)</span><br><span class="line">  <span class="keyword">if</span> (results.<span class="property">affectedRows</span> === <span class="number">1</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;插入成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>向表中新增数据时，如果数据对象的每个属性和数据表的字段一一对应，则可以通过如下方式快速插入数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">username</span>:<span class="string">&#x27;Bruce&#x27;</span>, <span class="attr">password</span>:<span class="string">&#x27;55520&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">&#x27;insert into users set ?&#x27;</span></span><br><span class="line">db.<span class="title function_">query</span>(sql, user, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.更新数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">&#x27;update users set username=?, password=? where id=?&#x27;</span></span><br><span class="line">db.<span class="title function_">query</span>(sql, [username, password, id], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>快捷方式<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;<span class="attr">id</span>:<span class="number">7</span>,<span class="attr">username</span>:<span class="string">&#x27;Bruce&#x27;</span>,<span class="attr">password</span>:<span class="string">&#x27;55520&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> sql = <span class="string">&#x27;update users set ? where id=?&#x27;</span></span><br><span class="line">db.<span class="title function_">query</span>(sql, [user, user.<span class="property">id</span>], <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>4.删除数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sql = <span class="string">&#x27;delete from users where id=?&#x27;</span></span><br><span class="line">db.<span class="title function_">query</span>(sql, id, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>使用 delete 语句会真正删除数据，保险起见，使用标记删除的形式，模拟删除的动作。即在表中设置状态字段，标记当前的数据是否被删除。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.<span class="title function_">query</span>(<span class="string">&#x27;update users set status=1 where id=?&#x27;</span>, <span class="number">7</span>, <span class="function">(<span class="params">err, results</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="Web-开发模式"><a href="#Web-开发模式" class="headerlink" title="Web 开发模式"></a>Web 开发模式</h2><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>服务器发送给客户端的 HTML 页面，是在服务器通过字符串的拼接动态生成的。因此客户端不需要使用 Ajax 额外请求页面的数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/index.html&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;Bruce&#x27;</span>, <span class="attr">age</span>: <span class="number">29</span> &#125;</span><br><span class="line">  <span class="keyword">const</span> html = <span class="string">`&lt;h1&gt;username:<span class="subst">$&#123;user.name&#125;</span>, age:<span class="subst">$&#123;user.age&#125;</span>&lt;/h1&gt;`</span></span><br><span class="line">  res.<span class="title function_">send</span>(html)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>前端耗时短。浏览器只需直接渲染页面，无需额外请求数据。</li><li>有利于 SEO。服务器响应的是完整的 HTML 页面内容，有利于爬虫爬取信息。  </li></ul><p>缺点：</p><ul><li>占用服务器资源。服务器需要完成页面内容的拼接，若请求比较多，会对服务器造成一定访问压力。</li><li>不利于前后端分离，开发效率低</li></ul><h3 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h3><p>前后端分离的开发模式，依赖于 Ajax 技术的广泛应用。后端只负责提供 API 接口，前端使用 Ajax 调用接口。<br>优点：</p><ul><li>开发体验好。前端专业页面开发，后端专注接口开发。</li><li>用户体验好。页面局部刷新，无需重新请求页面。</li><li>减轻服务器的渲染压力。页面最终在浏览器里生成。  </li></ul><p>缺点：</p><ul><li>不利于 SEO。完整的 HTML 页面在浏览器拼接完成，因此爬虫无法爬取页面的有效信息。Vue、React 等框架的 SSR（server side render）技术能解决 SEO 问题。</li></ul><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul><li>企业级网站，主要功能是展示，没有复杂交互，且需要良好的 SEO，可考虑服务端渲染</li><li>后台管理项目，交互性强，无需考虑 SEO，可使用前后端分离</li><li>为同时兼顾首页渲染速度和前后端分离开发效率，可采用首屏服务器端渲染+其他页面前后端分离的开发模式</li></ul><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><h3 id="Session-认证机制"><a href="#Session-认证机制" class="headerlink" title="Session 认证机制"></a>Session 认证机制</h3><p>服务端渲染推荐使用 Session 认证机制  </p><p>Session 工作原理  </p><p>  <img src="/.io//Session.png" alt="工作原理" title="Session 工作原理"></p><p>Express 中使用 Session 认证</p><p>1.安装 express-session 中间件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-session</span><br></pre></td></tr></table></figure><br>2.配置中间件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">&#x27;express-session&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(</span><br><span class="line">  <span class="title function_">session</span>(&#123;</span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&#x27;Bruce&#x27;</span>, <span class="comment">// secret 的值为任意字符串</span></span><br><span class="line">    <span class="attr">resave</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">saveUninitalized</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>3.向 session 中存数据  </p><p>中间件配置成功后，可通过 req.session 访问 session 对象，存储用户信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  req.<span class="property">session</span>.<span class="property">user</span> = req.<span class="property">body</span></span><br><span class="line">  req.<span class="property">session</span>.<span class="property">isLogin</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;login done&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4.从 session 取数据<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/api/username&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!req.<span class="property">session</span>.<span class="property">isLogin</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&#x27;fail&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;success&#x27;</span>, <span class="attr">username</span>: req.<span class="property">session</span>.<span class="property">user</span>.<span class="property">username</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>5.清空 session<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/logout&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 清空当前客户端的session信息</span></span><br><span class="line">  req.<span class="property">session</span>.<span class="title function_">destroy</span>()</span><br><span class="line">  res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&#x27;logout done&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="JWT-认证机制"><a href="#JWT-认证机制" class="headerlink" title="JWT 认证机制"></a>JWT 认证机制</h3><p>前后端分离推荐使用 JWT（JSON Web Token）认证机制，是目前最流行的跨域认证解决方案  </p><p>JWT 工作原理  </p><p>Session 认证的局限性：</p><ul><li>Session 认证机制需要配合 Cookie 才能实现。由于 Cookie 默认不支持跨域访问，所以，当涉及到前端跨域请求后端接口的时候，需要做很多额外的配置，才能实现跨域 Session 认证。</li><li>当前端请求后端接口不存在跨域问题的时候，推荐使用 Session 身份认证机制。</li><li>当前端需要跨域请求后端接口的时候，不推荐使用 Session 身份认证机制，推荐使用 JWT 认证机制</li></ul><p>JWT 工作原理图：  </p><p>用户的信息通过 Token 字符串的形式，保存在客户端浏览器中。服务器通过还原 Token 字符串的形式来认证用户的身份。  </p><p>  <img src="/.io//JWT.png" alt="工作原理" title="Session 工作原理"></p><p>JWT 组成部分：</p><ul><li>Header、Payload、Signature</li><li>Payload 是真正的用户信息，加密后的字符串</li><li>Header 和 Signature 是安全性相关部分，保证 Token 安全性</li><li>三者使用 . 分隔</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Header</span>.<span class="property">Payload</span>.<span class="property">Signature</span></span><br><span class="line"></span><br><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.<span class="property">eyJpZCI6MTcsInVzZXJuYW1lIjoiQnJ1Y2UiLCJwYXNzd29yZCI6IiIsIm5pY2tuYW1lIjoiaGVsbG8iLCJlbWFpbCI6InNjdXRAcXEuY29tIiwidXNlcl9waWMiOiIiLCJpYXQiOjE2NDE4NjU3MzEsImV4cCI6MTY0MTkwMTczMX0</span>.<span class="property">bmqzAkNSZgD8IZxRGGyVlVwGl7EGMtWitvjGD</span>-a5U5c</span><br></pre></td></tr></table></figure><p>JWT 使用方式：  </p><ul><li>客户端会把 JWT 存储在 localStorage 或 sessionStorage 中</li><li>此后客户端与服务端通信需要携带 JWT 进行身份认证，将 JWT 存在 HTTP 请求头 Authorization 字段中</li><li>加上 Bearer 前缀</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Authorization</span>: <span class="title class_">Bearer</span> &lt;token&gt;</span><br></pre></td></tr></table></figure><p>Express 使用 JWT</p><p>1.安装  </p><ul><li>jsonwebtoken 用于生成 JWT 字符串</li><li>express-jwt 用于将 JWT 字符串解析还原成 JSON 对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jsonwebtoken express-jwt</span><br></pre></td></tr></table></figure></li></ul><p>2.定义 secret 密钥  </p><ul><li>为保证 JWT 字符串的安全性，防止其在网络传输过程中被破解，需定义用于加密和解密的 secret 密钥</li><li>生成 JWT 字符串时，使用密钥加密信息，得到加密好的 JWT 字符串</li><li>把 JWT 字符串解析还原成 JSON 对象时，使用密钥解密</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> expressJWT = <span class="built_in">require</span>(<span class="string">&#x27;express-jwt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥为任意字符串</span></span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&#x27;Bruce&#x27;</span></span><br></pre></td></tr></table></figure><p>3.生成 JWT 字符串  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/api/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;登录成功&#x27;</span>,</span><br><span class="line">    <span class="comment">// jwt.sign() 生成 JWT 字符串</span></span><br><span class="line">    <span class="comment">// 参数：用户信息对象、加密密钥、配置对象-token有效期</span></span><br><span class="line">    <span class="comment">// 尽量不保存敏感信息，因此只有用户名，没有密码</span></span><br><span class="line">    <span class="attr">token</span>: jwt.<span class="title function_">sign</span>(&#123;<span class="attr">username</span>: userInfo.<span class="property">username</span>&#125;, secretKey, &#123;<span class="attr">expiresIn</span>: <span class="string">&#x27;10h&#x27;</span>&#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4.JWT 字符串还原为 JSON 对象  </p><ul><li>客户端访问有权限的接口时，需通过请求头的 Authorization 字段，将 Token 字符串发送到服务器进行身份认证</li><li>服务器可以通过 express-jwt 中间件将客户端发送过来的 Token 解析还原成 JSON 对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unless(&#123; path: [/^\/api\//] &#125;) 指定哪些接口无需访问权限</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">expressJWT</span>(&#123; <span class="attr">secret</span>: secretKey &#125;).<span class="title function_">unless</span>(&#123; <span class="attr">path</span>: [<span class="regexp">/^\/api\//</span>] &#125;))</span><br></pre></td></tr></table></figure></li></ul><p>5.获取用户信息  </p><ul><li>当 express-jwt 中间件配置成功后，即可在那些有权限的接口中，使用 req.user 对象，来访问从 JWT 字符串中解析出来的用户信息</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/admin/getinfo&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">user</span>)</span><br><span class="line">  res.<span class="title function_">send</span>(&#123;</span><br><span class="line">    <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;获取信息成功&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: req.<span class="property">user</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>6.捕获解析 JWT 失败后产生的错误  </p><ul><li>当使用 express-jwt 解析 Token 字符串时，如果客户端发送过来的 Token 字符串过期或不合法，会产生一个解析失败的错误，影响项目的正常运行</li><li>通过 Express 的错误中间件，捕获这个错误并进行相关的处理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">err, req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">name</span> === <span class="string">&#x27;UnauthorizedError&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">401</span>, <span class="attr">message</span>: <span class="string">&#x27;Invalid token&#x27;</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.<span class="title function_">send</span>(&#123; <span class="attr">status</span>: <span class="number">500</span>, <span class="attr">message</span>: <span class="string">&#x27;Unknown error&#x27;</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nodejs基础&quot;&gt;&lt;a href=&quot;#Nodejs基础&quot; class=&quot;headerlink&quot; title=&quot;Nodejs基础&quot;&gt;&lt;/a&gt;Nodejs基础&lt;/h1&gt;&lt;p&gt;  &lt;a href=&quot;http://nodejs.cn/&quot;&gt;官网传送门&lt;/a&gt;&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="Nodejs" scheme="https://yxiyu.github.io/categories/Nodejs/"/>
    
    
    <category term="Nodejs" scheme="https://yxiyu.github.io/tags/Nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Less浅记</title>
    <link href="https://yxiyu.github.io/posts/100e8d77"/>
    <id>https://yxiyu.github.io/posts/100e8d77</id>
    <published>2021-12-24T00:00:00.000Z</published>
    <updated>2022-10-22T05:17:40.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h1><p><a href="https://lesscss.com.cn/" title="less">传送门</a></p><blockquote><p>Less是一个CSS预处理器, Less文件后缀是.less<br>扩充了 CSS 语言, 使 CSS 具备一定的逻辑性、计算能力。<br>注意：浏览器不识别Less代码，目前阶段，网页要引入对应的CSS文件。</p></blockquote><h2 id="编译插件"><a href="#编译插件" class="headerlink" title="编译插件"></a>编译插件</h2><p>Easy Less :</p><ul><li>vscode插件</li><li>作用：less文件保存自动生成css文件</li></ul><h1 id="Less语法"><a href="#Less语法" class="headerlink" title="Less语法"></a>Less语法</h1><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><ol><li>加、减、乘直接书写计算表达式<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100</span> + <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100</span> - <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">5</span> * <span class="number">32px</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>除法需要添加 小括号 或 .<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: (<span class="number">100</span> / <span class="number">50px</span>);</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100</span> ./ <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">## 嵌套写法</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> 生成后代选择器。</span><br><span class="line"><span class="selector-tag">-</span> `<span class="selector-tag">&amp;</span>`表示当前选择器</span><br><span class="line">```<span class="selector-tag">less</span></span><br><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">    <span class="selector-class">.son</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: green</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Less变量设置属性值</p><ul><li>把颜色提前存储到一个容器，设置属性值为这个容器名</li><li>变量：存储数据，方便使用和修改</li><li>语法：<ul><li>定义变量：<code>@变量名: 值</code>;</li><li>使用变量：<code>CSS属性：@变量名</code>;<pre><code class="lang-less">// 定义@fontColor: pink.father &#123;// 使用color: @fontColor;.son &#123;  color: @fontColor&#125;&#125;</code></pre></li></ul></li></ul><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><blockquote><p>语法： <code>@import “文件路径”</code></p></blockquote><pre><code class="lang-less">// 如果是less文件， 则后缀名.less可以省略@import &#39;base.less&#39;;@import &#39;base&#39;;</code></pre><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><ul><li><p>Less文件<code>第一行</code>添加如下代码, <code>注意文件夹名称后面添加 /</code></p><blockquote><p>语法: <code>// out: ./css/</code></p><pre><code>  `// out: ./css/common.css`</code></pre></blockquote></li><li><p>禁止导出</p><blockquote><p>语法:<code>// out: false</code></p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Less&quot;&gt;&lt;a href=&quot;#Less&quot; class=&quot;headerlink&quot; title=&quot;Less&quot;&gt;&lt;/a&gt;Less&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://lesscss.com.cn/&quot; title=&quot;less&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;bl</summary>
      
    
    
    
    <category term="前端基础" scheme="https://yxiyu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Less" scheme="https://yxiyu.github.io/tags/Less/"/>
    
  </entry>
  
  <entry>
    <title>HTML+CSS笔记</title>
    <link href="https://yxiyu.github.io/posts/5160bc96"/>
    <id>https://yxiyu.github.io/posts/5160bc96</id>
    <published>2021-08-24T00:00:00.000Z</published>
    <updated>2022-10-22T05:17:40.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h1><blockquote><p>CSS 中规定每个盒子分别由：内容区域（content）、内边距区（padding）、边框区域（border）、外边距区域（margin ）构成，</p></blockquote><h2 id="外边距折叠-合并现象"><a href="#外边距折叠-合并现象" class="headerlink" title="外边距折叠  合并现象"></a>外边距折叠  <em>合并现象</em></h2><p>场景：<code>垂直布局</code> 的 <code>块级元素</code>，<code>上下</code>的<code>margin</code>会<code>合并</code><br>结果：最终<code>两者距离</code>为<code>margin的最大值</code><br>解决方法：避免就好  只给其中一个盒子<code>设置margin</code>即可</p><h2 id="外边距折叠-塌陷现象"><a href="#外边距折叠-塌陷现象" class="headerlink" title="外边距折叠 塌陷现象"></a>外边距折叠 <em>塌陷现象</em></h2><p>场景：<code>互相嵌套</code> 的 <code>块级元素</code>，<code>子元素</code>的 <code>margin-top</code> 会作用在<code>父元素</code>上<br>结果：导致<code>父元素</code>一起<code>往下移动</code><br>解决方法:</p><ul><li>给<code>父元素</code>设置<code>border-top</code> 或者 <code>padding-top</code>（分隔父子元素的margin-top）</li><li>给<code>父元素</code>设置<code>overflow：hidden</code></li><li>转换成<code>行内块元素</code></li><li>设置<code>浮动</code></li></ul><h1 id="浮动float"><a href="#浮动float" class="headerlink" title="浮动float"></a>浮动<code>float</code></h1><h2 id="浮动的特点"><a href="#浮动的特点" class="headerlink" title="浮动的特点"></a>浮动的特点</h2><ul><li>浮动元素会脱离标准流（简称：脱标），在标准流中不占位置 (相当于从地面飘到了空中 )</li><li>浮动元素比标准流高半个级别，可以覆盖标准流中的元素</li><li>浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动 </li><li>浮动元素会受到上面元素边界的影响</li><li>浮动元素有特殊的显示效果<ul><li>一行可以显示多个</li><li>可以设置宽高</li></ul></li></ul><blockquote><p>注意点：  浮动的元素不能通过<code>text-align:center</code>或者<code>margin:0 auto</code>，让浮动元素本身水平居中</p></blockquote><h2 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h2><p>清除 <code>浮动带来的影响</code></p><blockquote><p>影响：如果子元素浮动了，此时子元素不能撑开标准流的块级父元素<br>原因：子元素浮动后脱标 → 不占位置<br>目的：需要父元素有高度，从而不影响其他网页元素的布局</p></blockquote><h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><p><code>1、直接设置父元素高度</code></p><blockquote><p>   优点：简单粗暴，方便<br>   缺点：有些布局中不能固定父元素高度。如：新闻列表、京东推荐模块</p></blockquote><p><code>2、额外标签法</code></p><blockquote><p>  操作</p><pre><code>  1. 在父元素内容的最后添加一个块级元素   2. 给添加的块级元素设置 clear:both</code></pre><p>  缺点：会在页面中添加额外的标签，会让页面的HTML结构变得复杂</p></blockquote><p><code>3、单伪元素清除法</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写法： */</span></span><br><span class="line">   <span class="selector-class">.clearfix</span> <span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">       <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">       <span class="attribute">display</span>: block;</span><br><span class="line">       <span class="attribute">clear</span>: bath; </span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/* 若需隐藏 */</span></span><br><span class="line">   <span class="selector-class">.clearfix</span> <span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">       <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">       <span class="attribute">display</span>: block;</span><br><span class="line">       <span class="attribute">clear</span>: bath;</span><br><span class="line">       <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">       <span class="attribute">visibility</span>: hidden; </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure></p><p><code>4、双伪元素清除法</code><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> <span class="selector-pseudo">::before</span> , <span class="selector-class">.clearfix</span> <span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">       <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">       <span class="attribute">display</span>: block;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-class">.clearfix</span> <span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">       <span class="attribute">clear</span>: bath;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p><code>5、给父元素设置overflow : hidden</code>    </p><h1 id="定位-position"><a href="#定位-position" class="headerlink" title="定位 position"></a>定位 <code>position</code></h1><h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><p>子绝父相</p><ul><li>让子元素相对于父元素进行自由移动<ul><li>子元素：绝对定位</li><li>父元素：相对定位</li></ul></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>：relative；</span><br></pre></td></tr></table></figure><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>：absolute；</span><br></pre></td></tr></table></figure><h2 id="元素的层级关系"><a href="#元素的层级关系" class="headerlink" title="元素的层级关系"></a>元素的层级关系</h2><ul><li>不同布局方式元素的层级关系：标准流 &lt; 浮动 &lt; 定位</li><li>不同定位之间的层级关系：<ul><li>相对、绝对、固定默认层级相同</li><li>此时HTML中写在下面的元素层级更高，会覆盖上面的元素</li></ul></li></ul><h1 id="Flex-弹性布局"><a href="#Flex-弹性布局" class="headerlink" title="Flex 弹性布局"></a><code>Flex</code> 弹性布局</h1><h2 id="Flex布局模型构成"><a href="#Flex布局模型构成" class="headerlink" title="Flex布局模型构成"></a>Flex布局模型构成</h2><ul><li>作用<blockquote><p>基于 Flex 精确灵活控制块级盒子的布局方式，避免浮动布局中脱离文档流现象发生。<br>Flex布局非常适合结构化布局</p></blockquote></li><li>设置方式: 父元素添加 display: flex，子元素可以自动的挤压或拉伸</li><li>组成部分<ul><li>弹性容器</li><li>弹性盒子</li><li>主轴</li><li>侧轴 / 交叉轴</li></ul></li></ul><h2 id="主轴对齐方式"><a href="#主轴对齐方式" class="headerlink" title="主轴对齐方式"></a>主轴对齐方式</h2><blockquote><p><code>justify-content</code>调节元素在主轴的对齐方式</p></blockquote><div class="table-container"><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值, 起点开始依次排列</td></tr><tr><td>flex-end</td><td>终点开始依次排列</td></tr><tr><td><code>center</code></td><td>沿主轴居中排列</td></tr><tr><td>space-around</td><td>弹性盒子沿主轴均匀排列, 空白间距均分在弹性盒子两侧</td></tr><tr><td><code>space-between</code></td><td>弹性盒子沿主轴均匀排列, 空白间距均分在相邻盒子之间</td></tr><tr><td>space-evenly</td><td>弹性盒子沿主轴均匀排列, 弹性盒子与容器之间间距相等</td></tr></tbody></table></div><h2 id="侧轴对齐方式"><a href="#侧轴对齐方式" class="headerlink" title="侧轴对齐方式"></a>侧轴对齐方式</h2><blockquote><p><code>align-items</code>调节元素在侧轴的对齐方式</p></blockquote><div class="table-container"><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>flex-start</td><td>默认值, 起点开始依次排列</td></tr><tr><td>flex-end</td><td>终点开始依次排列</td></tr><tr><td><code>center</code></td><td>沿侧轴居中排列</td></tr><tr><td>stretch</td><td>默认值, 弹性盒子沿着主轴线被拉伸至铺满容器</td></tr></tbody></table></div><h2 id="主轴方向"><a href="#主轴方向" class="headerlink" title="主轴方向"></a>主轴方向</h2><p>Flex布局模型中，弹性盒子默认沿着水平方向排列<br>若要实现内容垂直排列需设置 flex-direction 属性   </p><blockquote><p><code>flex-direction</code>改变元素排列方向</p></blockquote><div class="table-container"><table><thead><tr><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>row</td><td>行, 水平(默认值)</td></tr><tr><td><code>column</code></td><td><code>* 列, 垂直</code></td></tr><tr><td>row-reverse</td><td>行, 从右向左</td></tr><tr><td>column-reverse</td><td>列, 从下向上</td></tr></tbody></table></div><h1 id="移动适配-媒体查询"><a href="#移动适配-媒体查询" class="headerlink" title="移动适配 -媒体查询"></a>移动适配 -媒体查询</h1><blockquote><p>rem</p><p>vw / vh</p></blockquote><h2 id="rem单位"><a href="#rem单位" class="headerlink" title="rem单位"></a>rem单位</h2><ul><li>相对单位</li><li>rem单位是相对于HTML标签的字号计算结果</li><li>1rem = 1HTML字号大小</li></ul><h2 id="rem移动适配"><a href="#rem移动适配" class="headerlink" title="rem移动适配"></a>rem移动适配</h2><ul><li><code>媒体查询</code>能够检测<code>视口的宽度</code>，然后编写差异化的 CSS 样式</li><li>目前<code>rem布局</code>方案中，将网页等分成<code>10份</code>， HTML标签的根字号为<code>视口宽度</code>的 <code>1/10</code><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (媒体特性) &#123;</span><br><span class="line">    选择器 &#123;</span><br><span class="line">        CSS属性</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* ---------------- */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">width</span> : <span class="number">320px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span> : <span class="number">32px</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="flexible"><a href="#flexible" class="headerlink" title="flexible"></a><code>flexible</code></h2><p><code>flexible.js</code>配合<code>rem</code>实现在不同宽度的设备中，网页元素尺寸<code>等比缩放</code>效果</p><ul><li>flexible.js是手淘开发出的一个用来适配移动端的<code>js框架</code>。</li><li><code>核心原理</code>就是根据不同的视口宽度给网页中html<code>根节点</code>设置不同的<code>font-size</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;盒子模型&quot;&gt;&lt;a href=&quot;#盒子模型&quot; class=&quot;headerlink&quot; title=&quot;盒子模型&quot;&gt;&lt;/a&gt;盒子模型&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;CSS 中规定每个盒子分别由：内容区域（content）、内边距区（padding）、边框区域（b</summary>
      
    
    
    
    <category term="前端基础" scheme="https://yxiyu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="HTML+CSS" scheme="https://yxiyu.github.io/tags/HTML-CSS/"/>
    
  </entry>
  
  <entry>
    <title>JS</title>
    <link href="https://yxiyu.github.io/posts/b92db53e"/>
    <id>https://yxiyu.github.io/posts/b92db53e</id>
    <published>2021-08-24T00:00:00.000Z</published>
    <updated>2022-10-22T05:17:40.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原生JS"><a href="#原生JS" class="headerlink" title="原生JS"></a>原生JS</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>基本数据类型</p><ul><li>number 数值型</li><li>string 字符串</li><li>boolean 布尔型</li><li>undefined 未定义</li><li>null 空引用</li></ul><p>引用数据类型</p><ul><li>object  对象</li><li>function  函数 </li><li>array    数组</li></ul><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><ul><li>转换成数字 <code>parse系列</code></li><li>转换成字符串 <code>.toString()</code></li></ul><p>技巧</p><ul><li>+号作为正号解析可以转换成Number</li><li>任何数据和字符串相加结果都是字符串</li></ul><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><p><code>push()</code><br>向数组末尾添加元素，返回新数组长度<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">520</span>, <span class="number">55520</span>, <span class="number">521</span>]</span><br><span class="line"><span class="comment">// 添加单个元素</span></span><br><span class="line"><span class="keyword">let</span> newLength = arr.<span class="title function_">push</span>(<span class="number">666</span>)<span class="comment">//4</span></span><br><span class="line"><span class="comment">// 添加多个元素</span></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">2333</span>, <span class="string">&#x27;BruceBlog&#x27;</span>)<span class="comment">//[520, 55520, 521, 666, 2333, &#x27;BruceBlog&#x27;]</span></span><br></pre></td></tr></table></figure></p><p><code>unshift()</code><br>数组头部添加元素，返回新数组长度<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">520</span>, <span class="number">55520</span>, <span class="number">521</span>]</span><br><span class="line"><span class="comment">// 添加单个元素</span></span><br><span class="line"><span class="keyword">let</span> newLength = arr.<span class="title function_">unshift</span>(<span class="number">666</span>)<span class="comment">//4</span></span><br><span class="line"><span class="comment">// 添加多个元素</span></span><br><span class="line">arr.<span class="title function_">unshift</span>(<span class="number">2333</span>, <span class="string">&#x27;BruceBlog&#x27;</span>) <span class="comment">// [2333, &#x27;BruceBlog&#x27;, 666, 520, 55520, 521]</span></span><br></pre></td></tr></table></figure></p><p><code>pop()</code><br>数组末尾删除一个元素，返回被删除的元素<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">520</span>, <span class="number">55520</span>, <span class="number">521</span>]</span><br><span class="line"><span class="keyword">let</span> el = arr.<span class="title function_">pop</span>()<span class="comment">//521</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组没有元素返回 undefined</span></span><br><span class="line">arr = []</span><br><span class="line">arr.<span class="title function_">pop</span>()</span><br></pre></td></tr></table></figure></p><p><code>shift()</code><br>数组头部删除一个元素，返回被删除的元素<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">520</span>, <span class="number">55520</span>, <span class="number">521</span>]</span><br><span class="line"><span class="keyword">let</span> el = arr.<span class="title function_">shift</span>()<span class="comment">//520</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组没有元素返回 undefined</span></span><br><span class="line">arr = []</span><br><span class="line">arr.<span class="title function_">shift</span>()</span><br></pre></td></tr></table></figure></p><p><code>splice()</code><br>可给数组删除、添加、替换元素，改变原数组</p><p>返回被删除元素组成的数组，没有删除元素则为空数组</p><p>参数：操作起始位置、删除的元素个数、添加的元素<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;JS&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;PHP&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="comment">// res:[&#x27;Java&#x27;, &#x27;C++&#x27;] arr: [&#x27;JS&#x27;, &#x27;PHP&#x27;], </span></span><br><span class="line">res = arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="comment">// arr:[&#x27;Python&#x27;, &#x27;TS&#x27;, &#x27;JS&#x27;, &#x27;PHP&#x27;], res:[]</span></span><br><span class="line">res = arr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;TS&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换元素（删除元素的同时添加新元素）</span></span><br><span class="line"><span class="comment">// arr:[&#x27;Python&#x27;, &#x27;C&#x27;, &#x27;Go&#x27;]</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;Go&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p><code>sort()</code><br>对数组进行排序，修改原数组，返回排序后的数组。</p><p>默认按字符串顺序升序排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">25</span>]</span><br><span class="line"><span class="comment">// [0, 10, 2, 25, 8]</span></span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">sort</span>()</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">res === arr</span><br></pre></td></tr></table></figure><p><code>sort()</code> 方法可传入一个比较函数，自定义比较规则。</p><p>比较函数传入两个参数：新数和旧数。返回正数则新数排在旧数之后，返回负值则新数排在旧数之前，返回 0 则相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compareAsc</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compareDes</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> b - a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compareRandom</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0.5</span> - <span class="title class_">Math</span>.<span class="title function_">random</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">0</span>, <span class="number">52</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">10</span>]</span><br><span class="line"><span class="comment">// [0, 8, 10, 25, 52]</span></span><br><span class="line">arr.<span class="title function_">sort</span>(compareAsc)</span><br><span class="line"></span><br><span class="line"><span class="comment">// [52, 25, 10, 8, 0]</span></span><br><span class="line">arr.<span class="title function_">sort</span>(compareDes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机排序数组</span></span><br><span class="line">arr.<span class="title function_">sort</span>(compareRandom)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据对象属性排序</span></span><br><span class="line"><span class="keyword">let</span> cars = [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;Benz&#x27;</span>, <span class="attr">year</span>: <span class="number">2021</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;Lexus&#x27;</span>, <span class="attr">year</span>: <span class="number">2022</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;BMW&#x27;</span>, <span class="attr">year</span>: <span class="number">2023</span> &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">cars.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = a.<span class="property">type</span>.<span class="title function_">toLowerCase</span>()</span><br><span class="line">  <span class="keyword">let</span> y = b.<span class="property">type</span>.<span class="title function_">toLowerCase</span>()</span><br><span class="line">  <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>reverse()</code><br>反转数组，改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line"><span class="comment">// [&#x27;green&#x27;, &#x27;blue&#x27;, &#x27;red&#x27;]</span></span><br><span class="line">arr.<span class="title function_">reverse</span>()</span><br></pre></td></tr></table></figure><h2 id="数组迭代"><a href="#数组迭代" class="headerlink" title="数组迭代"></a>数组迭代</h2><p><code>forEach()</code></p><p>遍历数组，对每个元素执行传入的函数。相当于使用 for 循环遍历数组。</p><p><code>forEach()</code> 没有返回值，不会改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">44</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  count += item</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// count: 50</span></span><br><span class="line"><span class="comment">// res: undefined</span></span><br></pre></td></tr></table></figure><p><code>filter()</code></p><p>过滤数组，返回符合条件的元素组成的新数组。不改变原数组。</p><p>传入一个筛选函数，筛选函数 3 个参数：元素、索引、数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">5</span>, <span class="number">23</span>, <span class="number">66</span>, <span class="number">520</span>, <span class="number">77</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> item &gt; <span class="number">50</span>)</span><br><span class="line"><span class="comment">// [66, 520, 77]</span></span><br></pre></td></tr></table></figure><p><code>map()</code><br>对数组每个元素执行传入的函数，返回每个执行结果组成的数组。不改变原数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> item * <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [3, 9, 15, 21]</span></span><br></pre></td></tr></table></figure><p><code>every()</code><br>检查数组每个元素是否都满足条件，若都返回 true，则 every() 方法返回 true。若有一个元素返回 false，则 every() 方法返回 false。</p><p>一旦遇到元素返回 false，则停止后续遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> item &lt; <span class="number">2</span>) <span class="comment">// false</span></span><br><span class="line">arr.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> item &gt; <span class="number">0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>some()</code><br>检查数组是否存在元素满足条件，若有一个元素返回 true，则 some() 方法返回 true。</p><p>一旦遇到元素返回 true，则停止后续遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">arr.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> item === <span class="number">6</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>reduce()</code><br>遍历数组，生成一个最终返回值，可用于条件统计。</p><p>reduce() 方法可传入 2 个参数：归并函数、初始值。其中初始值可选，若不传，则默认初始值为数组第一个元素，从数组第二个元素开始遍历。</p><p>归并函数可传入 4 个参数：上一个归并值、元素、索引、数组本身。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组元素累加</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> pre + cur) <span class="comment">// 15</span></span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> pre + cur, <span class="number">10</span>) <span class="comment">// 25</span></span><br></pre></td></tr></table></figure></p><p><code>reduceRight()</code></p><p>效果与 reduce() 方法相同，只是方向相反，从右往左遍历。</p><h1 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h1><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><blockquote><p>API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。<br>简单理解： API 是给程序员提供的一种工具，以便能更轻松的实现想要完成的功能。</p></blockquote><h2 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API">传送门</a><br><img src="/.io//../../img/avatar.jpg" alt="sdd"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原生JS&quot;&gt;&lt;a href=&quot;#原生JS&quot; class=&quot;headerlink&quot; title=&quot;原生JS&quot;&gt;&lt;/a&gt;原生JS&lt;/h1&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="前端基础" scheme="https://yxiyu.github.io/categories/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="JS" scheme="https://yxiyu.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
